<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TaskRaptor</title>
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            min-width: 550px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin-bottom: 10px;
            font-size: 2em;
        }
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        .auth-section {
            padding: 40px;
            text-align: center;
        }
        .auth-section input {
            width: 100%;
            max-width: 500px;
            padding: 12px;
            margin: 10px 0;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
        }
        .auth-section button {
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s;
        }
        .auth-section button:hover {
            background: #5568d3;
        }
        .controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 20px;
            align-items: start;
        }
        .controls-left {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        .controls-right {
            display: flex;
            flex-wrap: wrap-reverse;
            gap: 15px;
            align-items: center;
            justify-content: flex-end;
        }
        @media (max-width: 575px) {
            .controls-right {
                flex-direction: column-reverse;
                align-items: flex-end;
            }
        }
        .controls button, .controls select {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.95em;
        }
        .controls button:hover {
            background: #f8f9fa;
        }
        .filter-chip {
            display: inline-flex;
            align-items: center;
            background: #e0e0e0;
            color: #333;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 0.9em;
            gap: 8px;
            margin: 0 4px;
        }
        .filter-chip-delete {
            cursor: pointer;
            font-weight: bold;
            color: #666;
            background: none;
            border: none;
            padding: 0;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 1.1em;
            transition: background 0.2s;
        }
        .filter-chip-delete:hover {
            background: #bbb;
            color: #000;
        }
        .summary {
            padding: 20px 30px;
            background: #e9ecef;
            font-size: 0.95em;
            color: #495057;
        }
        .progress-container {
            padding: 40px;
            text-align: center;
        }
        .progress-bar {
            width: 100%;
            max-width: 600px;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px auto;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            border-radius: 15px;
        }
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-weight: bold;
            font-size: 0.9em;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .content {
            padding: 30px;
        }
        .task-item {
            padding: 15px;
            border-left: 4px solid transparent;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            transition: all 0.2s;
        }
        .task-item:hover {
            background: #e9ecef;
            border-left-color: #667eea;
        }
        .task-item.completed {
            opacity: 0.6;
        }
        .task-header {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            flex-wrap: wrap;
        }
        .task-header-main {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 1;
            min-width: 0;
        }
        .expand-icon {
            font-size: 0.8em;
            color: #6c757d;
            cursor: pointer;
            user-select: none;
            width: 20px;
            display: inline-block;
            flex-shrink: 0;
        }
        .task-checkbox {
            cursor: pointer;
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }
        .task-name {
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
            color: #333;
            font-size: 14px;
            max-width: 100%;
        }
        .task-name.completed {
            text-decoration: line-through;
            color: #6c757d;
        }
        .task-meta {
            display: inline-flex;
            gap: 10px;
            font-size: 0.85em;
            color: #6c757d;
            flex-shrink: 0;
            margin-left: 4px;
        }
        .task-header-buttons {
            display: flex;
            flex-direction: row-reverse;
            gap: 8px;
            flex-shrink: 0;
            margin-left: auto;
        }
        .due-date {
            padding: 2px 8px;
            background: #fff3cd;
            border-radius: 4px;
        }
        .due-date.overdue {
            background: #f8d7da;
            color: #721c24;
        }
        .breadcrumb {
            padding: 4px 0 8px 0;
            font-size: 0.80em;
            color: #6c757d;
            margin-bottom: 2px;
        }
        .breadcrumb-link {
            color: #6c757d;
            text-decoration: none;
            cursor: pointer;
            transition: color 0.2s;
        }
        .breadcrumb-link:hover {
            color: #495057;
            text-decoration: underline;
        }
        .task-details {
            margin-top: 15px;
            padding-left: 30px;
        }
        .btn-edit, .btn-delete, .btn-action {
            padding: 5px 12px;
            background: white;
            color: #495057;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            margin-left: 5px;
        }
        .btn-edit:hover, .btn-delete:hover, .btn-action:hover {
            background: #f8f9fa;
        }
        .task-header:hover .btn-edit,
        .task-header:hover .btn-action,
        .comment:hover .btn-edit,
        .comment:hover .btn-delete,
        .notes-container:hover > div > .btn-edit {
            opacity: 1;
            pointer-events: auto;
        }
        .task-item.completed .due-date {
            opacity: 0;
            pointer-events: none;
        }
        .task-item.completed:hover .due-date {
            opacity: 1;
            pointer-events: auto;
        }
        .task-loading-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 8px;
            vertical-align: middle;
        }
        .background-update-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 8px;
            vertical-align: middle;
        }
        body:not(.background-loading) .background-update-spinner {
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Global spinner for all expanded tasks during background loading */
        .global-update-spinner {
            padding: 8px;
            color: #6c757d;
            font-size: 0.9em;
            border-bottom: 1px solid #dee2e6;
            margin-bottom: 10px;
            background: #f8f9fa;
        }
        .global-update-spinner::before {
            content: "";
            display: inline-block;
            width: 14px;
            height: 14px;
            margin-right: 6px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            vertical-align: middle;
        }
        .editor-container {
            margin-top: 15px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
        }
        .editor-actions {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
        .notes-content p {
            margin: 0 0 10px 0;
            display: block;
        }
        .notes-content p:first-child {
            margin-top: 0;
        }
        .notes-content p:last-child {
            margin-bottom: 0;
        }
        .notes-content a {
            color: #667eea;
            text-decoration: none;
        }
        .notes-content a:hover {
            text-decoration: underline;
        }
        /* Fix bullet point indentation */
        .notes-content ul,
        .notes-content ol,
        .comment-content ul,
        .comment-content ol {
            margin: 0 0 10px 0;
            padding-left: 30px;
        }
        .notes-content ul:first-child,
        .notes-content ol:first-child,
        .comment-content ul:first-child,
        .comment-content ol:first-child {
            margin-top: 0;
        }
        .notes-content ul:last-child,
        .notes-content ol:last-child,
        .comment-content ul:last-child,
        .comment-content ol:last-child {
            margin-bottom: 0;
        }
        .notes-content li,
        .comment-content li {
            margin: 5px 0;
        }
        .notes-content,
        .comment-content {
            line-height: 1.6;
        }
        .notes-content.collapsed,
        .comment-content.collapsed {
            max-height: 4.8em; /* 3 lines √ó 1.6 line-height */
            overflow: hidden;
            position: relative;
            box-sizing: content-box; /* Make max-height only apply to content, not padding */
        }
        .notes-content.collapsed::after,
        .comment-content.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3.2em;
            background: linear-gradient(to bottom, 
                rgba(255,255,255,0) 0%, 
                rgba(255,255,255,0.3) 25%,
                rgba(255,255,255,0.6) 50%, 
                rgba(255,255,255,0.85) 75%,
                rgba(255,255,255,1) 100%);
            pointer-events: none;
        }
        .notes-content.no-gradient::after,
        .comment-content.no-gradient::after {
            display: none;
        }
        .show-more-btn {
            color: #667eea;
            background: none;
            border: none;
            padding: 5px 0;
            cursor: pointer;
            font-size: 0.9em;
            text-decoration: none;
        }
        .show-more-btn:hover {
            text-decoration: underline;
        }
        .comments-section {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
        .comment {
            padding: 10px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .comment-author {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }
        .comment-date {
            font-size: 0.8em;
            color: #6c757d;
            margin-bottom: 5px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
        }
        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideDown 0.3s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes slideDown {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .modal h2 {
            margin-bottom: 20px;
            color: #333;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #495057;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
        }
        .radio-group {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .radio-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .modal-body {
            margin: 20px 0;
        }
        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
        }
        .modal-footer button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            background: #667eea;
            color: white;
        }
        .modal-footer button:hover {
            background: #5568d3;
        }
        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        .modal-actions button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
        }
        .btn-primary {
            background: #667eea;
            color: white;
        }
        .btn-primary:hover {
            background: #5568d3;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #5a6268;
        }
        .toast {
            position: fixed;
            right: 20px;
            background: white;
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 12px;
            max-width: 400px;
            z-index: 2000;
            animation: slideIn 0.3s forwards;
            transition: top 0.3s ease;
        }
        .toast.hiding {
            animation: slideOut 0.3s forwards;
        }
        .toast.error { border-left: 4px solid #dc3545; }
        .toast.success { border-left: 4px solid #28a745; }
        .toast.info { border-left: 4px solid #17a2b8; }
        .toast.warning { border-left: 4px solid #ffc107; }
        .toast-close {
            margin-left: auto;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2em;
            color: #6c757d;
        }
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü¶ñ TaskRaptor ü¶Ö</h1>
            <p>View and manage your assigned tasks from Asana with filtering, sorting, and caching</p>
        </div>

        <div id="authSection" class="auth-section">
            <h2>Connect to Asana</h2>
            <p style="margin: 20px 0;">Enter your Personal Access Token to get started</p>
            <input type="password" id="patInput" placeholder="Paste your Asana Personal Access Token here" />
            <br>
            <button onclick="authenticate()">Connect</button>
            <p style="margin-top: 20px; font-size: 0.9em; color: #666;">
                Get your token from: <a href="https://app.asana.com/0/my-apps" target="_blank">https://app.asana.com/0/my-apps</a>
            </p>
        </div>

        <div id="mainSection" style="display: none;">
            <div class="controls">
                <div class="controls-left">
                    <button onclick="showInfoModal()">‚ÑπÔ∏è Info</button>
                    <select id="sortSelect" onchange="applySorting()">
                        <option value="name">Sort by Name</option>
                        <option value="due_date">Sort by Due Date</option>
                        <option value="completed">Sort by Status</option>
                        <option value="modified">Sort by Last Modified</option>
                    </select>
                    <button onclick="showFilterModal()">üîç Filters</button>
                    <div id="filterBadges"></div>
                </div>
                <div class="controls-right">
                    <button onclick="refreshData()">üîÑ Refresh</button>
                    <button onclick="logout()">üö™ Logout</button>
                </div>
            </div>

            <div id="summary" class="summary"></div>

            <div id="progressSection" class="progress-container" style="display: none;">
                <div class="spinner"></div>
                <p id="progressMessage">Loading tasks...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%;"></div>
                    <div id="progressText" class="progress-text">0%</div>
                </div>
            </div>

            <div id="content" class="content"></div>
        </div>
    </div>

    <!-- Generic Modal Container -->
    <div id="genericModal" class="modal">
        <div class="modal-content" id="genericModalContent">
            <!-- Content will be injected here -->
        </div>
    </div>

    <!-- Filter Modal -->
    <div id="filterModal" class="modal">
        <div class="modal-content">
            <h2>Filter Tasks</h2>
            
            <div class="form-group">
                <label>Completion Status</label>
                <div class="radio-group">
                    <label>
                        <input type="radio" name="completionFilter" value="uncompleted" checked>
                        Incomplete Only
                    </label>
                    <label>
                        <input type="radio" name="completionFilter" value="completed">
                        Completed Only
                    </label>
                    <label>
                        <input type="radio" name="completionFilter" value="both">
                        Both
                    </label>
                </div>
            </div>

            <div class="form-group">
                <label for="dateRangeType">Date Filter</label>
                <select id="dateRangeType" onchange="toggleCustomDateRange()">
                    <option value="last7">Last 7 days</option>
                    <option value="last30" selected>Last 30 days</option>
                    <option value="last90">Last 90 days</option>
                    <option value="custom">Custom range</option>
                    <option value="all">All time</option>
                </select>
            </div>

            <div id="customDateRange" class="form-group" style="display: none;">
                <label for="startDate">Start Date</label>
                <input type="date" id="startDate">
                <label for="endDate" style="margin-top: 10px;">End Date</label>
                <input type="date" id="endDate">
            </div>

            <div class="form-group">
                <label for="parentFilter">Filter by Parent Project</label>
                <select id="parentFilter">
                    <option value="">All Projects</option>
                </select>
            </div>

            <div class="modal-actions">
                <button class="btn-secondary" onclick="closeFilterModal()">Cancel</button>
                <button class="btn-primary" onclick="applyFilters()">Apply Filters</button>
            </div>
        </div>
    </div>

    <script>
        let WORKSPACE_ID = null;
        let personalAccessToken = '';
        let currentUserId = '';
        let allTasksMap = new Map();
        let rootItems = [];
        let activeEditor = null;
        let commentEditors = new Map();
        let cachedData = null;
        let allParents = new Set();
        let expandStates = {}; // Track expand/collapse state by task GID
        const tasksBeingLoaded = new Set(); // Track which tasks are currently loading
        
        // Filter state
        let filterState = {
            completion: 'uncompleted',
            dateRange: 'last30',
            customStart: null,
            customEnd: null,
            parentFilter: ''
        };

        // Load filter state from localStorage
        function loadFilterState() {
            const saved = localStorage.getItem('taskraptor_filters');
            if (saved) {
                filterState = JSON.parse(saved);
                console.log('Loaded filter state from localStorage:', filterState);
            } else {
                console.log('No saved filter state, using defaults:', filterState);
            }
        }

        // Save filter state to localStorage
        function saveFilterState() {
            try {
                localStorage.setItem('taskraptor_filters', JSON.stringify(filterState));
            } catch (error) {
                console.error('Failed to save filter state:', error);
                if (error.name === 'QuotaExceededError') {
                    showToast('Storage full: Unable to save filter preferences', 'error');
                }
            }
        }

        // Expand state management
        function saveExpandStates() {
            try {
                localStorage.setItem('taskraptor_expand_states', JSON.stringify(expandStates));
            } catch (error) {
                console.error('Failed to save expand states:', error);
                if (error.name === 'QuotaExceededError') {
                    showToast('Storage full: Unable to save task expand states', 'error');
                }
            }
        }

        function loadExpandStates() {
            const saved = localStorage.getItem('taskraptor_expand_states');
            if (saved) {
                expandStates = JSON.parse(saved);
            }
        }

        // PAT management
        function savePAT(token) {
            try {
                localStorage.setItem('taskraptor_pat', token);
            } catch (error) {
                console.error('Failed to save PAT:', error);
                if (error.name === 'QuotaExceededError') {
                    showToast('Storage full: Unable to save access token. Clear browser data and try again.', 'error', 8000);
                }
            }
        }

        function loadPAT() {
            return localStorage.getItem('taskraptor_pat');
        }

        function clearPAT() {
            localStorage.removeItem('taskraptor_pat');
        }

        // Workspace management
        function saveWorkspaceId(workspaceId) {
            try {
                localStorage.setItem('taskraptor_workspace_id', workspaceId);
            } catch (error) {
                console.error('Failed to save workspace ID:', error);
                if (error.name === 'QuotaExceededError') {
                    showToast('Storage full: Unable to save workspace selection', 'error');
                }
            }
        }

        function loadWorkspaceId() {
            return localStorage.getItem('taskraptor_workspace_id');
        }

        function clearWorkspaceId() {
            localStorage.removeItem('taskraptor_workspace_id');
        }

        // Cache management
        function saveCache(data) {
            const cacheData = {
                timestamp: Date.now(),
                data: data
            };
            try {
                localStorage.setItem('taskraptor_cache', JSON.stringify(cacheData));
            } catch (error) {
                console.error('Failed to save cache:', error);
                if (error.name === 'QuotaExceededError') {
                    showToast('Storage full: Cache not saved. Tasks will reload on next visit. Consider clearing old browser data.', 'error', 8000);
                    // Optionally clear cache to free space
                    try {
                        localStorage.removeItem('taskraptor_cache');
                    } catch (e) {
                        console.error('Failed to clear cache:', e);
                    }
                }
            }
        }

        function loadCache() {
            const cached = localStorage.getItem('taskraptor_cache');
            if (!cached) return null;
            
            const cacheData = JSON.parse(cached);
            const ageHours = (Date.now() - cacheData.timestamp) / (1000 * 60 * 60);
            
            // Cache valid for 24 hours
            if (ageHours > 24) {
                localStorage.removeItem('taskraptor_cache');
                return null;
            }
            
            return cacheData.data;
        }

        function clearCache() {
            localStorage.removeItem('taskraptor_cache');
        }

        // Toast notifications
        function showToast(message, type = 'info', duration = 5000) {
            const icons = {
                error: '‚ùå',
                success: '‚úÖ',
                info: '‚ÑπÔ∏è',
                warning: '‚ö†Ô∏è'
            };
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span style="font-size: 1.2em;">${icons[type]}</span>
                <span>${message}</span>
                <span class="toast-close">√ó</span>
            `;
            
            // Position toast in stack
            const existingToasts = document.querySelectorAll('.toast:not(.hiding)');
            let topPosition = 20;
            existingToasts.forEach(t => {
                topPosition += t.offsetHeight + 10;
            });
            toast.style.top = topPosition + 'px';
            
            document.body.appendChild(toast);
            
            // Remove toast function
            const removeToast = () => {
                if (!document.body.contains(toast)) return;
                
                toast.classList.add('hiding');
                
                // Wait for animation to complete
                const handleAnimationEnd = () => {
                    if (document.body.contains(toast)) {
                        toast.remove();
                        repositionToasts();
                    }
                };
                
                toast.addEventListener('animationend', handleAnimationEnd, { once: true });
            };
            
            // Auto-hide after duration
            const hideTimeout = setTimeout(removeToast, duration);
            
            // Manual close
            toast.querySelector('.toast-close').onclick = () => {
                clearTimeout(hideTimeout);
                removeToast();
            };
        }
        
        function repositionToasts() {
            const toasts = document.querySelectorAll('.toast:not(.hiding)');
            let topPosition = 20;
            toasts.forEach(toast => {
                toast.style.top = topPosition + 'px';
                topPosition += toast.offsetHeight + 10;
            });
        }

        // Progress tracking
        function updateProgress(current, total, message) {
            const percent = Math.round((current / total) * 100);
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = percent + '%';
            document.getElementById('progressMessage').textContent = message;
        }

        function showProgress() {
            document.getElementById('progressSection').style.display = 'block';
            document.getElementById('content').style.display = 'none';
        }

        function hideProgress() {
            document.getElementById('progressSection').style.display = 'none';
            document.getElementById('content').style.display = 'block';
        }

        function showBackgroundLoadingBanner() {
            // Remove any existing toast
            const existing = document.getElementById('backgroundLoadingToast');
            if (existing) existing.remove();
            
            const toast = document.createElement('div');
            toast.id = 'backgroundLoadingToast';
            toast.className = 'toast';
            
            // Position toast in stack with other toasts
            const existingToasts = document.querySelectorAll('.toast:not(.hiding)');
            let topPosition = 20;
            existingToasts.forEach(t => {
                if (t.id !== 'backgroundLoadingToast') {
                    topPosition += t.offsetHeight + 10;
                }
            });
            
            toast.style.cssText = `
                position: fixed;
                top: ${topPosition}px;
                right: 20px;
                background: white;
                border-left: 4px solid #667eea;
                padding: 16px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 2000;
                display: flex;
                align-items: center;
                gap: 12px;
                min-width: 300px;
                animation: slideIn 0.3s forwards;
                transition: top 0.3s ease;
            `;
            
            toast.innerHTML = `
                <div class="spinner" style="width: 20px; height: 20px; border: 3px solid #f3f3f3; border-top: 3px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <span style="color: #333; font-weight: 500;">Updating tasks in background...</span>
            `;
            
            // Add spinner animation if not already in styles
            if (!document.getElementById('spinnerStyle')) {
                const style = document.createElement('style');
                style.id = 'spinnerStyle';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                    @keyframes slideIn {
                        from { transform: translateX(400px); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(400px); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(toast);
        }

        function showGlobalUpdateSpinners() {
            // Spinners are now always in HTML, just shown via CSS when body has background-loading class
        }

        function hideGlobalUpdateSpinners() {
            // Spinners are now hidden via CSS when body.background-loading class is removed
        }

        function hideBackgroundLoadingBanner() {
            const toast = document.getElementById('backgroundLoadingToast');
            if (toast) {
                toast.classList.add('hiding');
                // Override the inline animation to trigger slideOut
                toast.style.animation = 'slideOut 0.3s ease forwards';
                const handleAnimationEnd = () => {
                    if (document.body.contains(toast)) {
                        toast.remove();
                        repositionToasts();
                    }
                };
                toast.addEventListener('animationend', handleAnimationEnd, { once: true });
            }
            window.backgroundLoadingInProgress = false;
            document.body.classList.remove('background-loading');
            hideGlobalUpdateSpinners();
        }

        // Authentication
        async function authenticate() {
            const token = document.getElementById('patInput').value.trim();
            if (!token) {
                showToast('Please enter your Personal Access Token', 'error');
                return;
            }

            personalAccessToken = token;
            savePAT(token);
            await authenticateAndLoad();
        }

        async function authenticateAndLoad() {
            try {
                const response = await fetch('https://app.asana.com/api/1.0/users/me', {
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Invalid token');
                }

                const data = await response.json();
                currentUserId = data.data.gid;

                // Try to load saved workspace ID
                WORKSPACE_ID = loadWorkspaceId();
                
                // If no saved workspace, fetch and let user select
                if (!WORKSPACE_ID) {
                    await selectWorkspace();
                }

                document.getElementById('authSection').style.display = 'none';
                document.getElementById('mainSection').style.display = 'block';

                loadFilterState();
                
                // Try to load from cache first
                cachedData = loadCache();
                if (cachedData) {
                    showToast('Loading from cache...', 'info', 2000);
                    displayCachedData();
                    // Refresh in background
                    setTimeout(() => refreshData(true), 1000);
                } else {
                    await loadUserTasks();
                }

            } catch (error) {
                showToast('Authentication failed: ' + error.message, 'error');
                clearPAT();
                clearWorkspaceId();
            }
        }

        async function selectWorkspace() {
            try {
                const response = await fetch('https://app.asana.com/api/1.0/workspaces', {
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch workspaces');
                }

                const data = await response.json();
                const workspaces = data.data;

                if (workspaces.length === 0) {
                    throw new Error('No workspaces found');
                }

                if (workspaces.length === 1) {
                    // Only one workspace, use it automatically
                    WORKSPACE_ID = workspaces[0].gid;
                    saveWorkspaceId(WORKSPACE_ID);
                } else {
                    // Multiple workspaces, show selector
                    await showWorkspaceSelector(workspaces);
                }

            } catch (error) {
                throw new Error('Workspace selection failed: ' + error.message);
            }
        }

        async function showWorkspaceSelector(workspaces) {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'flex';
                
                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                modalContent.style.maxWidth = '500px';
                
                modalContent.innerHTML = `
                    <h2 style="margin-bottom: 20px;">Select Workspace</h2>
                    <p style="margin-bottom: 20px; color: #666;">Choose which Asana workspace to use with TaskRaptor:</p>
                    <select id="workspaceSelect" style="width: 100%; padding: 10px; margin-bottom: 20px; border: 2px solid #ddd; border-radius: 6px; font-size: 1em;">
                        ${workspaces.map(ws => `<option value="${ws.gid}">${ws.name}</option>`).join('')}
                    </select>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="workspaceConfirm" class="btn" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">Continue</button>
                    </div>
                `;
                
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                document.getElementById('workspaceConfirm').onclick = () => {
                    const selectedWorkspaceId = document.getElementById('workspaceSelect').value;
                    WORKSPACE_ID = selectedWorkspaceId;
                    saveWorkspaceId(selectedWorkspaceId);
                    document.body.removeChild(modal);
                    resolve();
                };
            });
        }

        function displayCachedData() {
            allTasksMap = new Map(cachedData.allTasksMap);
            rootItems = cachedData.rootItems;
            allParents = new Set(cachedData.allParents);
            
            // Check for and remove duplicates in cached data
            const uniqueGids = new Set();
            const dedupedRootItems = [];
            rootItems.forEach(task => {
                if (!uniqueGids.has(task.gid)) {
                    uniqueGids.add(task.gid);
                    dedupedRootItems.push(task);
                } else {
                    console.warn(`Removed duplicate from cache: ${task.name} (${task.gid})`);
                }
            });
            
            if (dedupedRootItems.length !== rootItems.length) {
                console.log(`Cache had ${rootItems.length - dedupedRootItems.length} duplicates, now ${dedupedRootItems.length} unique items`);
                rootItems = dedupedRootItems;
            }
            
            // Mark all items as loading in the background
            window.backgroundLoadingInProgress = true;
            document.body.classList.add('background-loading');
            
            populateParentFilter();
            displayTasks();
            displayFilterBadges();
            
            // Show a subtle banner indicating background refresh
            showBackgroundLoadingBanner();
            
            // Add spinners to all expanded tasks
            showGlobalUpdateSpinners();
        }

        async function refreshData(background = false) {
            if (!background) {
                clearCache();
                showProgress();
            }
            await loadUserTasks(background);
        }

        function collapseSingleChildChains() {
            // For each root item, if it only has one child and that child is not a real task,
            // replace the root with the deepest descendant in the single-child chain
            const newRootItems = [];
            
            rootItems.forEach(rootItem => {
                let current = rootItem;
                const chainItems = [current];
                
                // Walk down the chain as long as there's only one child
                while (current.subtasks && current.subtasks.length === 1) {
                    const onlyChild = current.subtasks[0];
                    chainItems.push(onlyChild);
                    current = onlyChild;
                }
                
                // If we walked down a chain (more than 1 item), use the leaf as the root
                if (chainItems.length > 1) {
                    const leaf = chainItems[chainItems.length - 1];
                    // Store just the GIDs and names to avoid circular references
                    leaf.collapsedParentChain = chainItems.slice(0, -1).map(item => ({
                        gid: item.gid,
                        name: item.name
                    }));
                    newRootItems.push(leaf);
                    console.log(`Collapsed chain: ${chainItems.map(i => i.name).join(' ‚Üí ')}`);
                } else {
                    newRootItems.push(rootItem);
                }
            });
            
            rootItems = newRootItems;
        }

        function createMissingParentItems() {
            const referencedParents = new Set();
            const existingGids = new Set();
            
            // First pass: collect all existing GIDs and referenced parent IDs
            allTasksMap.forEach(task => {
                existingGids.add(task.gid);
                if (task.parent && task.parent.gid) {
                    referencedParents.add(task.parent.gid);
                }
            });
            
            console.log(`Found ${existingGids.size} existing tasks and ${referencedParents.size} referenced parents`);
            
            // Second pass: create placeholder items for missing parents
            const tasksToProcess = Array.from(allTasksMap.values());
            tasksToProcess.forEach(task => {
                // If task has a parent that doesn't exist as a task, create it
                if (task.parent && task.parent.gid && !existingGids.has(task.parent.gid)) {
                    // Check memberships to get proper name and hierarchy
                    if (task.memberships && task.memberships.length > 0) {
                        const membership = task.memberships[0];
                        
                        // Check if this is a section
                        if (membership.section && membership.section.gid === task.parent.gid) {
                            const sectionItem = {
                                gid: membership.section.gid,
                                name: membership.section.name,
                                completed: false,
                                isSection: true,
                                subtasks: [],
                                memberships: [membership]
                            };
                            
                            // Section's parent is the project
                            if (membership.project && membership.project.gid) {
                                sectionItem.parent = {
                                    gid: membership.project.gid,
                                    name: membership.project.name
                                };
                            }
                            
                            allTasksMap.set(sectionItem.gid, sectionItem);
                            existingGids.add(sectionItem.gid);
                            console.log(`Created section item: ${sectionItem.name}`);
                            
                            // Also create project if needed
                            if (membership.project && !existingGids.has(membership.project.gid)) {
                                const projectItem = {
                                    gid: membership.project.gid,
                                    name: membership.project.name,
                                    completed: false,
                                    isProject: true,
                                    subtasks: [],
                                    parent: null
                                };
                                allTasksMap.set(projectItem.gid, projectItem);
                                existingGids.add(projectItem.gid);
                                console.log(`Created project item: ${projectItem.name}`);
                            }
                        }
                    } else {
                        // No memberships data, create a basic placeholder
                        const placeholderItem = {
                            gid: task.parent.gid,
                            name: task.parent.name || 'Unknown Parent',
                            completed: false,
                            isPlaceholder: true,
                            subtasks: [],
                            parent: null
                        };
                        allTasksMap.set(placeholderItem.gid, placeholderItem);
                        existingGids.add(placeholderItem.gid);
                        console.log(`Created placeholder item: ${placeholderItem.name}`);
                    }
                } else if (!task.parent && task.memberships && task.memberships.length > 0) {
                    // Task has no parent but has memberships - create project/section hierarchy
                    const membership = task.memberships[0];
                    
                    // Create project if needed
                    if (membership.project && !existingGids.has(membership.project.gid)) {
                        const projectItem = {
                            gid: membership.project.gid,
                            name: membership.project.name,
                            completed: false,
                            isProject: true,
                            subtasks: [],
                            parent: null
                        };
                        allTasksMap.set(projectItem.gid, projectItem);
                        existingGids.add(projectItem.gid);
                        console.log(`Created project item: ${projectItem.name}`);
                    }
                    
                    // Create section if needed
                    if (membership.section && !existingGids.has(membership.section.gid)) {
                        const sectionItem = {
                            gid: membership.section.gid,
                            name: membership.section.name,
                            completed: false,
                            isSection: true,
                            subtasks: [],
                            parent: membership.project ? {
                                gid: membership.project.gid,
                                name: membership.project.name
                            } : null
                        };
                        allTasksMap.set(sectionItem.gid, sectionItem);
                        existingGids.add(sectionItem.gid);
                        console.log(`Created section item: ${sectionItem.name}`);
                    }
                    
                    // Link task to section or project
                    if (membership.section) {
                        task.parent = {
                            gid: membership.section.gid,
                            name: membership.section.name
                        };
                        console.log(`Linked task "${task.name}" to section "${membership.section.name}"`);
                    } else if (membership.project) {
                        task.parent = {
                            gid: membership.project.gid,
                            name: membership.project.name
                        };
                        console.log(`Linked task "${task.name}" to project "${membership.project.name}"`);
                    }
                }
            });
            
            console.log(`After creating missing parents: ${allTasksMap.size} total items`);
        }

        // Fetch all tasks with pagination
        async function loadUserTasks(background = false) {
            try {
                if (!background) showProgress();
                
                let currentProgress = 0;
                const setProgress = (progress, message) => {
                    currentProgress = progress;
                    updateProgress(currentProgress, 100, message);
                };

                setProgress(0, 'Fetching your tasks...');

                // Build API URL with filters
                // Include memberships to get project/section hierarchy
                let apiUrl = `https://app.asana.com/api/1.0/tasks?assignee=${currentUserId}&workspace=${WORKSPACE_ID}&opt_fields=name,completed,assignee,due_on,modified_at,parent,notes,html_notes,memberships,memberships.project,memberships.project.name,memberships.section,memberships.section.name`;
                
                // Add API-level filters based on completion status and date range
                const dateFilter = getDateFilter();
                
                if (filterState.completion === 'completed') {
                    // For completed tasks, use completed_since
                    apiUrl += '&completed=true';
                    if (dateFilter) {
                        apiUrl += `&completed_since=${dateFilter}`;
                    }
                } else if (filterState.completion === 'uncompleted') {
                    // For uncompleted tasks, use modified_since to reduce payload
                    apiUrl += '&completed=false';
                    if (dateFilter && filterState.dateRange !== 'all') {
                        apiUrl += `&modified_since=${dateFilter}`;
                    }
                } else {
                    // For 'both' mode, use modified_since if date filter is set
                    if (dateFilter && filterState.dateRange !== 'all') {
                        apiUrl += `&modified_since=${dateFilter}`;
                    }
                }

                const allTasks = [];
                let offset = null;
                let pageCount = 0;

                do {
                    const url = offset ? `${apiUrl}&offset=${offset}` : apiUrl;
                    const response = await fetch(url, {
                        headers: { 'Authorization': `Bearer ${personalAccessToken}` }
                    });

                    if (!response.ok) throw new Error('Failed to fetch tasks');

                    const data = await response.json();
                    allTasks.push(...data.data);
                    
                    pageCount++;
                    const fetchProgress = Math.min(30, (allTasks.length / 200) * 30);
                    setProgress(fetchProgress, `Fetched ${allTasks.length} tasks (page ${pageCount})...`);

                    offset = data.next_page ? data.next_page.offset : null;
                } while (offset);

                setProgress(35, `Processing ${allTasks.length} tasks...`);

                // Filter by date if needed and initialize structure
                const filteredTasks = filterTasksByDate(allTasks).map(task => {
                    // Ensure task has required structure
                    if (!task.subtasks) task.subtasks = [];
                    if (task.comments === undefined) task.comments = null;
                    task.subtasksLoaded = false; // Mark as not loaded yet
                    return task;
                });
                console.log(`After date filter: ${filteredTasks.length} tasks (from ${allTasks.length})`);
                console.log('Sample tasks:', filteredTasks.slice(0, 3).map(t => ({name: t.name, completed: t.completed, hasParent: !!t.parent})));

                // If background loading, preserve existing tasks and merge new data
                // Otherwise, clear and rebuild
                if (!background) {
                    allTasksMap.clear();
                    filteredTasks.forEach(task => allTasksMap.set(task.gid, task));
                } else {
                    // During background loading, UPDATE existing tasks instead of replacing them
                    filteredTasks.forEach(task => {
                        const existingTask = allTasksMap.get(task.gid);
                        if (existingTask) {
                            // Update only the core task properties, preserve UI state and loaded data
                            existingTask.name = task.name;
                            existingTask.completed = task.completed;
                            existingTask.assignee = task.assignee;
                            existingTask.due_on = task.due_on;
                            existingTask.modified_at = task.modified_at;
                            existingTask.parent = task.parent;
                            existingTask.notes = task.notes;
                            existingTask.html_notes = task.html_notes;
                            existingTask.memberships = task.memberships;
                            // Keep existing: comments, notesExpanded, commentsShown, subtasks, subtasksLoaded
                        } else {
                            // New task, add it
                            allTasksMap.set(task.gid, task);
                        }
                    });
                }

                // Create placeholder items for missing parents (projects/sections)
                createMissingParentItems();

                // Load subtasks for all filtered tasks - this will add more tasks to allTasksMap
                setProgress(40, 'Loading subtasks...');
                for (let i = 0; i < filteredTasks.length; i++) {
                    tasksBeingLoaded.add(filteredTasks[i].gid); // Mark as loading
                    const isAssignedToUser = true; // all filteredTasks are assigned to user
                    await loadSubtasksFiltered(filteredTasks[i].gid, isAssignedToUser);
                    tasksBeingLoaded.delete(filteredTasks[i].gid); // Mark as loaded
                    if (i % 5 === 0 || i === filteredTasks.length - 1) {
                        const subtaskProgress = 40 + ((i / filteredTasks.length) * 30);
                        setProgress(subtaskProgress, `Loading subtasks: ${i + 1}/${filteredTasks.length}`);
                    }
                }

                // NOW build hierarchy - allTasksMap contains all tasks and their subtasks
                setProgress(70, 'Building task hierarchy...');
                
                // First, build parent-child relationships for projects/sections
                // Clear any existing subtasks arrays for projects/sections
                allTasksMap.forEach(task => {
                    if (task.isProject || task.isSection) {
                        task.subtasks = [];
                    }
                });
                
                // Build the subtasks arrays based on parent relationships
                allTasksMap.forEach(task => {
                    if (task.parent && task.parent.gid) {
                        const parent = allTasksMap.get(task.parent.gid);
                        if (parent) {
                            if (!parent.subtasks) {
                                parent.subtasks = [];
                            }
                            // Only add if not already present
                            if (!parent.subtasks.some(st => st.gid === task.gid)) {
                                parent.subtasks.push(task);
                            }
                        }
                    }
                });
                
                rootItems = [];
                allParents.clear();
                const rootGids = new Set(); // Track which GIDs we've added as roots
                const trueRootMap = new Map(); // Maps task GID to its true root GID

                // Iterate through ALL tasks in allTasksMap to find their true roots
                const allTasksArray = Array.from(allTasksMap.values());
                console.log(`Building hierarchy from ${allTasksArray.length} total tasks (including subtasks)`);
                
                for (let i = 0; i < allTasksArray.length; i++) {
                    const task = allTasksArray[i];
                    
                    // Find the TRUE root by walking up the parent chain
                    const parentChain = await getParentChain(task.gid);
                    const trueRoot = parentChain.length > 0 ? parentChain[0] : task;
                    
                    // Store mapping from this task to its true root
                    trueRootMap.set(task.gid, trueRoot.gid);
                    
                    if (i < 5) {
                        console.log(`Task ${i}: "${task.name}" (GID: ${task.gid})`);
                        console.log(`  Has parent: ${task.parent ? 'yes (' + task.parent.gid + ')' : 'no'}`);
                        console.log(`  Parent object:`, task.parent);
                        console.log(`  Parent chain length: ${parentChain.length}`);
                        if (parentChain.length > 0) {
                            console.log(`  Parent chain:`, parentChain.map(p => p.name).join(' ‚Üí '));
                        }
                        console.log(`  True root: "${trueRoot.name}" (${trueRoot.gid})`);
                        console.log(`  Subtasks: ${task.subtasks ? task.subtasks.length : 0}`);
                    }
                    
                    // Add true root to rootItems if not already added
                    if (!rootGids.has(trueRoot.gid)) {
                        rootItems.push(trueRoot);
                        rootGids.add(trueRoot.gid);
                        
                        if (rootItems.length <= 5) {
                            console.log(`‚úì Added root #${rootItems.length}: "${trueRoot.name}" (${trueRoot.gid})`);
                        }
                        
                        // Add to parent filter options
                        allParents.add(JSON.stringify({
                            gid: trueRoot.gid,
                            name: trueRoot.name
                        }));
                    }
                    
                    if (i % 10 === 0) {
                        const hierarchyProgress = 70 + ((i / allTasksArray.length) * 20);
                        setProgress(hierarchyProgress, `Building hierarchy: ${i + 1}/${allTasksArray.length}`);
                    }
                }
                
                console.log(`Total root items found: ${rootItems.length}`);
                console.log(`rootGids size: ${rootGids.size}`);
                console.log(`allTasksMap size: ${allTasksMap.size}`);
                
                // Check for duplicates
                const uniqueGids = new Set(rootItems.map(t => t.gid));
                if (uniqueGids.size !== rootItems.length) {
                    console.warn(`‚ö†Ô∏è Found ${rootItems.length - uniqueGids.size} duplicate root items!`);
                    // Remove duplicates
                    const seen = new Set();
                    rootItems = rootItems.filter(task => {
                        if (seen.has(task.gid)) {
                            console.log(`  Removing duplicate: ${task.name} (${task.gid})`);
                            return false;
                        }
                        seen.add(task.gid);
                        return true;
                    });
                    console.log(`After deduplication: ${rootItems.length} root items`);
                }
                
                // Collapse single-child chains into breadcrumbs
                collapseSingleChildChains();
                console.log(`After collapsing single-child chains: ${rootItems.length} root items`);
                
                setProgress(90, 'Finalizing...');

                // Save to cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });

                populateParentFilter();
                
                // Only re-render if NOT background loading
                // During background load, we skip displayTasks() to avoid destroying expanded tasks
                if (!background) {
                    displayTasks();
                }
                
                displayFilterBadges();
                
                setProgress(100, 'Complete!');
                
                // Store refresh timestamp
                window.lastRefreshTime = new Date();
                
                showToast(`Loaded ${filteredTasks.length} tasks successfully`, 'success', 2000);
                
                if (!background) {
                    hideProgress();
                } else {
                    hideBackgroundLoadingBanner();
                }

            } catch (error) {
                console.error(error);
                showToast('Error loading tasks: ' + error.message, 'error');
                if (!background) {
                    hideProgress();
                } else {
                    hideBackgroundLoadingBanner();
                }
            } finally {
                // Ensure background loading flag is always cleared
                if (background && window.backgroundLoadingInProgress) {
                    window.backgroundLoadingInProgress = false;
                    document.body.classList.remove('background-loading');
                    hideGlobalUpdateSpinners();
                    
                    // Now that background loading is complete, refresh the display
                    displayTasks();
                }
            }
        }

        function getDateFilter() {
            const now = new Date();
            let filterDate = null;

            switch (filterState.dateRange) {
                case 'last7':
                    filterDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    break;
                case 'last30':
                    filterDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                    break;
                case 'last90':
                    filterDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                    break;
                case 'custom':
                    if (filterState.customStart) {
                        filterDate = new Date(filterState.customStart);
                    }
                    break;
                case 'all':
                    return null;
            }

            return filterDate ? filterDate.toISOString() : null;
        }

        function filterTasksByDate(tasks) {
            // Most date filtering now happens at API level
            // This function only does additional client-side filtering for 'both' mode
            
            if (filterState.dateRange === 'all') return tasks;
            if (filterState.completion === 'uncompleted' || filterState.completion === 'completed') {
                // API already filtered these, so return as-is
                return tasks;
            }

            // For 'both' mode: API filtered by modified_since, but we need to keep all uncompleted
            // and filter completed by completion date
            const dateFilter = getDateFilter();
            if (!dateFilter) return tasks;

            const filterTime = new Date(dateFilter).getTime();

            return tasks.filter(task => {
                if (!task.completed) return true; // Always show uncompleted
                // For completed tasks in 'both' mode, check if completed within range
                if (!task.modified_at) return true;
                const modifiedTime = new Date(task.modified_at).getTime();
                return modifiedTime >= filterTime;
            });
        }

        function populateParentFilter() {
            const select = document.getElementById('parentFilter');
            select.innerHTML = '<option value="">All Projects</option>';
            
            const parentArray = Array.from(allParents).map(p => JSON.parse(p));
            parentArray.sort((a, b) => a.name.localeCompare(b.name));
            
            parentArray.forEach(parent => {
                const option = document.createElement('option');
                option.value = parent.gid;
                option.textContent = parent.name;
                if (parent.gid === filterState.parentFilter) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        async function getParentChain(taskGid) {
            const chain = [];
            let currentTask = allTasksMap.get(taskGid);
            
            if (!currentTask) {
                // Try fetching from API if not in map
                currentTask = await getTaskDetails(taskGid);
            }
            
            if (!currentTask) return chain;
            
            // Build chain from parent relationships
            // Parent items should already exist in allTasksMap thanks to createMissingParentItems()
            while (currentTask && currentTask.parent) {
                // Look up parent in map first (don't fetch projects/sections from API)
                const parent = allTasksMap.get(currentTask.parent.gid);
                if (!parent) break;
                chain.unshift(parent);
                currentTask = parent;
            }
            
            return chain;
        }

        async function getTaskDetails(taskGid) {
            // Return from cache if already fetched
            if (allTasksMap.has(taskGid)) {
                return allTasksMap.get(taskGid);
            }

            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}?opt_fields=name,completed,assignee,due_on,modified_at,parent,notes,html_notes`, {
                    headers: { 'Authorization': `Bearer ${personalAccessToken}` }
                });

                if (!response.ok) return null;

                const data = await response.json();
                const task = data.data;
                
                // Preserve existing comments and UI state if task already exists
                const existingTask = allTasksMap.get(task.gid);
                if (existingTask) {
                    task.comments = existingTask.comments;
                    task.notesExpanded = existingTask.notesExpanded;
                    task.commentsShown = existingTask.commentsShown;
                    task.subtasks = existingTask.subtasks || [];
                } else {
                    task.subtasks = [];
                    task.comments = null;
                }
                
                allTasksMap.set(task.gid, task);
                return task;
            } catch (error) {
                console.error('Error fetching task:', error);
                return null;
            }
        }

        async function loadSubtasksFiltered(taskGid, parentAssignedToUser) {
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            // Skip if this is a project or section (not a real task)
            if (task.isProject || task.isSection || task.isPlaceholder) {
                task.subtasksLoaded = true; // Mark as loaded so we don't try again
                return;
            }
            
            // If subtasks already loaded, skip
            if (task.subtasksLoaded) {
                return;
            }

            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}/subtasks?opt_fields=name,completed,assignee,due_on,modified_at,parent,notes,html_notes`, {
                    headers: { 'Authorization': `Bearer ${personalAccessToken}` }
                });

                if (!response.ok) return;

                const data = await response.json();
                task.subtasks = [];
                task.subtasksLoaded = true; // Mark as loaded

                for (const subtask of data.data) {
                    const isAssignedToUser = subtask.assignee && subtask.assignee.gid === currentUserId;
                    const isUnassigned = !subtask.assignee;
                    
                    if (isAssignedToUser || (isUnassigned && parentAssignedToUser)) {
                        // Preserve existing comments and UI state if subtask already exists
                        const existingSubtask = allTasksMap.get(subtask.gid);
                        if (existingSubtask) {
                            subtask.comments = existingSubtask.comments;
                            subtask.notesExpanded = existingSubtask.notesExpanded;
                            subtask.commentsShown = existingSubtask.commentsShown;
                            subtask.subtasks = existingSubtask.subtasks || [];
                            subtask.subtasksLoaded = existingSubtask.subtasksLoaded || false;
                        } else {
                            subtask.subtasks = [];
                            subtask.comments = null;
                            subtask.subtasksLoaded = false;
                        }
                        
                        allTasksMap.set(subtask.gid, subtask);
                        task.subtasks.push(subtask);
                        
                        await loadSubtasksFiltered(subtask.gid, isAssignedToUser);
                    }
                }
            } catch (error) {
                console.error('Error loading subtasks:', error);
            }
        }

        function displayTasks() {
            const content = document.getElementById('content');
            content.innerHTML = '';

            console.log('displayTasks called');
            console.log('Root items before filtering:', rootItems.length);
            console.log('Filter state:', filterState);

            // Apply parent filter
            let tasksToDisplay = rootItems;
            if (filterState.parentFilter) {
                // Filter to show only tasks that are the selected parent OR descendants of it
                tasksToDisplay = rootItems.filter(task => {
                    if (task.gid === filterState.parentFilter) {
                        return true; // This IS the parent
                    }
                    // Check if this task is a descendant of the filter parent
                    return isDescendantOf(task.gid, filterState.parentFilter);
                });
            }
            console.log('After parent filter:', tasksToDisplay.length);

            // Apply completion status filter
            tasksToDisplay = filterTasksByCompletion(tasksToDisplay);
            console.log('After completion filter:', tasksToDisplay.length);

            // Apply sorting
            tasksToDisplay = sortTasks(tasksToDisplay);

            if (tasksToDisplay.length === 0) {
                content.innerHTML = '<div style="text-align: center; padding: 40px; color: #6c757d;">No tasks found with current filters. Check browser console for debug info.</div>';
                return;
            }

            tasksToDisplay.forEach(task => {
                const taskElement = renderTask(task, 0, true);
                content.appendChild(taskElement);
            });

            updateSummary(tasksToDisplay);
        }

        function filterTasksByCompletion(tasks) {
            console.log('filterTasksByCompletion called with', tasks.length, 'tasks');
            console.log('Completion filter mode:', filterState.completion);
            
            if (filterState.completion === 'both') {
                console.log('Filter mode is "both" - returning all tasks');
                return tasks;
            }

            const showCompleted = filterState.completion === 'completed';
            console.log('Show completed:', showCompleted);

            function filterRecursive(task) {
                // Projects and sections should always pass through (they contain tasks)
                if (task.isProject || task.isSection || task.isPlaceholder) {
                    // Filter their subtasks recursively
                    if (task.subtasks && task.subtasks.length > 0) {
                        const filteredSubtasks = task.subtasks
                            .map(filterRecursive)
                            .filter(t => t !== null);
                        
                        // Include this container if it has any matching subtasks
                        if (filteredSubtasks.length > 0) {
                            return {
                                ...task,
                                subtasks: filteredSubtasks
                            };
                        }
                    }
                    return null;
                }
                
                // Check if this task matches the filter
                const matches = task.completed === showCompleted;
                
                // Filter subtasks recursively
                if (task.subtasks && task.subtasks.length > 0) {
                    const filteredSubtasks = task.subtasks
                        .map(filterRecursive)
                        .filter(t => t !== null);
                    
                    // If this task matches OR has matching subtasks, include it
                    if (matches || filteredSubtasks.length > 0) {
                        return {
                            ...task,
                            subtasks: filteredSubtasks
                        };
                    }
                } else if (matches) {
                    // Leaf task that matches
                    return task;
                }
                
                return null;
            }

            const result = tasks
                .map(filterRecursive)
                .filter(t => t !== null);
            
            console.log('After filtering:', result.length, 'tasks remain');
            console.log('Sample tasks:', result.slice(0, 3).map(t => ({name: t.name, completed: t.completed})));
            
            return result;
        }

        function sortTasks(tasks) {
            const sortBy = document.getElementById('sortSelect').value;
            const sorted = [...tasks];

            switch (sortBy) {
                case 'name':
                    sorted.sort((a, b) => a.name.localeCompare(b.name));
                    break;
                case 'due_date':
                    sorted.sort((a, b) => {
                        if (!a.due_on && !b.due_on) return 0;
                        if (!a.due_on) return 1;
                        if (!b.due_on) return -1;
                        return new Date(a.due_on) - new Date(b.due_on);
                    });
                    break;
                case 'completed':
                    sorted.sort((a, b) => {
                        if (a.completed === b.completed) return 0;
                        return a.completed ? 1 : -1;
                    });
                    break;
                case 'modified':
                    sorted.sort((a, b) => {
                        if (!a.modified_at && !b.modified_at) return 0;
                        if (!a.modified_at) return 1;
                        if (!b.modified_at) return -1;
                        return new Date(b.modified_at) - new Date(a.modified_at);
                    });
                    break;
            }

            return sorted;
        }

        function applySorting() {
            displayTasks();
        }

        function updateSummary(tasks) {
            let totalTasks = 0;
            let completedTasks = 0;

            function countTasks(task) {
                totalTasks++;
                if (task.completed) completedTasks++;
                if (task.subtasks) {
                    task.subtasks.forEach(countTasks);
                }
            }

            tasks.forEach(countTasks);

            // Determine data source status
            let dataSourceStatus;
            if (window.backgroundLoadingInProgress) {
                dataSourceStatus = 'Displaying from local cache; Refreshing...';
            } else if (window.lastRefreshTime) {
                const timeStr = window.lastRefreshTime.toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });
                dataSourceStatus = `Refreshed from Asana at ${timeStr}`;
            } else {
                dataSourceStatus = 'Data source unknown';
            }
            
            // Store info for modal
            window.taskDebugInfo = {
                completionFilter: filterState.completion,
                dateFilter: filterState.dateRange,
                rootItems: rootItems.length,
                afterFilters: tasks.length,
                totalTasks: totalTasks,
                completedTasks: completedTasks,
                remainingTasks: totalTasks - completedTasks,
                dataSource: dataSourceStatus
            };
            
            // Summary bar now only shows basic count info
            document.getElementById('summary').innerHTML = '';
        }

        // Recursive function to check if all descendants are complete
        function areAllDescendantsComplete(task) {
            // If the task itself is marked complete, all its descendants are considered complete
            if (task.completed) {
                return true;
            }
            
            if (!task.subtasks || task.subtasks.length === 0) {
                // Leaf task: check its own completion status
                return task.completed;
            }
            
            // Has subtasks: check if all subtasks and their descendants are complete
            return task.subtasks.every(st => {
                const subtask = allTasksMap.get(st.gid);
                if (!subtask) return false;
                
                // Recursively check this subtask
                return areAllDescendantsComplete(subtask);
            });
        }

        function renderTask(task, level, isRoot = false) {
            // Check if this is a non-task (section, project, or placeholder)
            const isNonTask = task.isSection || task.isProject || task.isPlaceholder;
            
            // For non-tasks, recursively check if all descendants are complete
            let allSubtasksComplete = false;
            if (isNonTask && task.subtasks && task.subtasks.length > 0) {
                allSubtasksComplete = areAllDescendantsComplete(task);
            }
            
            // Determine display completion status
            const displayAsCompleted = task.completed || (isNonTask && allSubtasksComplete);
            
            const div = document.createElement('div');
            div.className = `task-item ${displayAsCompleted ? 'completed' : ''}`;
            div.style.marginLeft = (level * 5) + 'px';
            div.dataset.taskId = task.gid;

            // Determine if item should be expandable (has any content besides name)
            const hasSubtasks = task.subtasks && task.subtasks.length > 0;
            const hasNotes = task.notes && task.notes.trim().length > 0;
            const hasComments = task.comments && task.comments.length > 0;
            const hasAssignee = task.assignee && task.assignee.name;
            const hasDueDate = task.due_on;
            
            // Item is expandable if it has subtasks, notes, or comments
            const isExpandable = hasSubtasks || hasNotes || hasComments;
            
            // Item should show expand/collapse UI only if expandable AND has other fields
            const showExpandUI = isExpandable && (hasAssignee || hasDueDate || hasNotes || hasComments || hasSubtasks);
            
            // Check if this task should be expanded (from saved state only)
            let isExpanded = false;
            if (expandStates[task.gid] !== undefined) {
                isExpanded = expandStates[task.gid];
            }
            
            // Calculate descendant count (direct children only)
            const descendantCount = hasSubtasks ? task.subtasks.length : 0;
            const descendantBadge = descendantCount > 0 ? `<span style="color: #6c757d; font-size: 0.85em; margin-left: 4px;">  ${descendantCount} ‚ÅÇ</span>` : '';
            
            // Only show expand icon if item is actually expandable
            const expandIcon = showExpandUI ? `<span class="expand-icon" onclick="toggleTaskExpand(event, '${task.gid}')">${isExpanded ? '‚ñº' : '‚ñ∂'}</span>` : '<span class="expand-icon"></span>';

            // Due date button (always shown on right side)
            let dueDateDisplay = task.due_on ? `üìÖ ${task.due_on}` : 'üìÖ Add Due Date';
            let dueDateClass = '';
            let dueDateStyle = task.due_on ? 'opacity: 1; pointer-events: auto;' : '';
            if (task.due_on) {
                const dueDate = new Date(task.due_on);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const isOverdue = dueDate < today && !displayAsCompleted;
                dueDateClass = isOverdue ? 'overdue' : '';
            }

            let breadcrumbHtml = '';
            // Show full parent hierarchy for root items
            if (isRoot) {
                let parentChain = getParentChainFromMap(task.gid);
                
                // If this task has a collapsed parent chain, prepend it
                if (task.collapsedParentChain && task.collapsedParentChain.length > 0) {
                    parentChain = [...task.collapsedParentChain, ...parentChain];
                }
                
                if (parentChain.length > 0) {
                    breadcrumbHtml = '<div class="breadcrumb">';
                    
                    // Add all parents in the chain
                    breadcrumbHtml += parentChain.map(p => 
                        `<span style="color: #6c757d;">${escapeHtml(p.name)}</span>`
                    ).join(' ‚Üí ');
                    breadcrumbHtml += ' ‚Üí ';
                    
                    // Add current task name (slightly darker)
                    breadcrumbHtml += `<span style="color: #495057; font-weight: 500;">${escapeHtml(task.name)}</span>`;
                    breadcrumbHtml += '</div>';
                }
            }

            div.innerHTML = `
                ${breadcrumbHtml}
                <div class="task-header" ${showExpandUI ? `onclick="toggleTaskExpand(event, '${task.gid}')"` : ''}>
                    <div class="task-header-main">
                        ${expandIcon}
                        ${!isNonTask ? `<input type="checkbox" class="task-checkbox" 
                               ${task.completed ? 'checked' : ''} 
                               onclick="toggleTaskCompletion(event, '${task.gid}')" />` : ''}
                        <span class="task-name ${displayAsCompleted ? 'completed' : ''}">${escapeHtml(task.name)}</span>
                        <span class="task-meta">${descendantBadge}</span>
                        ${tasksBeingLoaded.has(task.gid) ? '<span class="task-loading-spinner" title="Loading..."></span>' : ''}
                        <span class="background-update-spinner"></span>
                    </div>
                    <div class="task-header-buttons">
                        <button class="btn-action due-date ${dueDateClass}" onclick="setDueDate(event, '${task.gid}')" style="${dueDateStyle}" title="Set Due Date">${dueDateDisplay}</button>
                        <button class="btn-action" onclick="createSubtask(event, '${task.gid}')" title="Add Subtask">‚ûï Subtask</button>
                        <button class="btn-action rename" onclick="renameTask(event, '${task.gid}')" title="Rename">‚úèÔ∏è Rename</button>
                        ${!hasNotes && !task.isProject && !task.isSection && !task.isPlaceholder ? '<button class="btn-action" onclick="editTaskNotes(event, \''+task.gid+'\')" title="Add Notes">üìù Notes</button>' : ''}
                    </div>
                </div>
                <div id="details-${task.gid}" class="task-details" style="display: ${isExpanded ? 'block' : 'none'};">
                    ${isExpanded && window.backgroundLoadingInProgress ? '<div class="background-loading-spinner" style="padding: 8px; color: #6c757d; font-size: 0.9em; border-bottom: 1px solid #dee2e6; margin-bottom: 10px;"><div class="spinner" style="display: inline-block; width: 14px; height: 14px; margin-right: 6px; border: 2px solid #f3f3f3; border-top: 2px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite;"></div>Updating...</div>' : ''}
                </div>
            `;

            // If expanded, trigger rendering of details after element is added to DOM
            if (isExpanded) {
                setTimeout(async () => {
                    const detailsDiv = document.getElementById(`details-${task.gid}`);
                    if (!detailsDiv) return;
                    
                    // Check if there's already a spinner from the initial render
                    const hasSpinner = detailsDiv.querySelector('.background-loading-spinner');
                    
                    // Check if background loading is in progress - add spinner if not already there
                    if (window.backgroundLoadingInProgress && !hasSpinner) {
                        const spinnerDiv = document.createElement('div');
                        spinnerDiv.className = 'background-loading-spinner';
                        spinnerDiv.style.cssText = 'padding: 8px; color: #6c757d; font-size: 0.9em; border-bottom: 1px solid #dee2e6; margin-bottom: 10px;';
                        spinnerDiv.innerHTML = '<div class="spinner" style="display: inline-block; width: 14px; height: 14px; margin-right: 6px; border: 2px solid #f3f3f3; border-top: 2px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite;"></div>Updating...';
                        detailsDiv.appendChild(spinnerDiv);
                    }
                    
                    // Load comments if not loaded (only for actual tasks, not projects/sections)
                    if (!task.comments && !task.isProject && !task.isSection && !task.isPlaceholder) {
                        await loadComments(task.gid);
                    }
                    
                    // Load subtasks if not loaded
                    if (!task.subtasksLoaded) {
                        const isAssignedToUser = task.assignee && task.assignee.gid === currentUserId;
                        await loadSubtasksFiltered(task.gid, isAssignedToUser);
                    }
                    
                    await renderTaskDetails(task.gid);
                }, 0);
            }

            return div;
        }

        function getParentChainFromMap(taskGid) {
            const chain = [];
            const task = allTasksMap.get(taskGid);
            if (!task) return chain;

            // First, try to build chain from task parent relationships
            if (task.parent) {
                let currentGid = task.parent.gid;
                const visited = new Set(); // Prevent infinite loops
                
                while (currentGid && !visited.has(currentGid)) {
                    visited.add(currentGid);
                    const parent = allTasksMap.get(currentGid);
                    if (!parent) break;
                    chain.unshift(parent);
                    currentGid = parent.parent ? parent.parent.gid : null;
                }
            }
            
            // If chain is still empty, try to build from project/section memberships
            if (chain.length === 0 && task.memberships && task.memberships.length > 0) {
                // Get the first membership (tasks can be in multiple projects)
                const membership = task.memberships[0];
                
                // Add project to chain
                if (membership.project && membership.project.name) {
                    chain.push({
                        gid: membership.project.gid,
                        name: membership.project.name,
                        isProject: true
                    });
                }
                
                // Add section to chain (if exists)
                if (membership.section && membership.section.name) {
                    chain.push({
                        gid: membership.section.gid,
                        name: membership.section.name,
                        isSection: true
                    });
                }
            }

            return chain;
        }

        function isDescendantOf(taskGid, ancestorGid) {
            // Check if taskGid is a descendant of ancestorGid by walking up the parent chain
            const task = allTasksMap.get(taskGid);
            if (!task || !task.parent) return false;

            let currentGid = task.parent.gid;
            const visited = new Set(); // Prevent infinite loops
            
            while (currentGid && !visited.has(currentGid)) {
                if (currentGid === ancestorGid) {
                    return true; // Found the ancestor
                }
                visited.add(currentGid);
                const parent = allTasksMap.get(currentGid);
                if (!parent) break;
                currentGid = parent.parent ? parent.parent.gid : null;
            }

            return false;
        }

        function filterByParent(parentGid) {
            filterState.parentFilter = parentGid;
            saveFilterState();
            displayTasks();
            displayFilterBadges();
            document.getElementById('parentFilter').value = parentGid;
        }

        async function toggleTaskExpand(event, taskGid) {
            // Don't toggle if clicking on checkbox or edit button
            if (event.target.classList.contains('task-checkbox') || 
                event.target.classList.contains('btn-edit')) {
                return;
            }

            event.stopPropagation();
            
            const taskElement = document.querySelector(`[data-task-id="${taskGid}"]`);
            const detailsDiv = document.getElementById('details-' + taskGid);
            const task = allTasksMap.get(taskGid);
            const icon = taskElement ? taskElement.querySelector('.expand-icon') : null;

            if (!task || !detailsDiv) return;

            const isExpanded = detailsDiv.style.display !== 'none';

            if (isExpanded) {
                // Collapse
                detailsDiv.style.display = 'none';
                if (icon) icon.textContent = '‚ñ∂';
                expandStates[taskGid] = false;
            } else {
                // Expand
                detailsDiv.style.display = 'block';
                if (icon) icon.textContent = '‚ñº';
                expandStates[taskGid] = true;

                // Check if details div already has content (from previous expansion)
                const hasRenderedContent = detailsDiv.innerHTML.trim().length > 0 && 
                                          !detailsDiv.querySelector('.loading-indicator');

                // If already rendered, just show it - don't reload unless needed
                if (hasRenderedContent) {
                    // Content already exists, just make it visible
                } else {
                    // Need to load/render content
                    // Mark task as loading and add spinner
                    tasksBeingLoaded.add(taskGid);
                    const taskNameSpan = taskElement.querySelector('.task-name');
                    if (taskNameSpan && !taskNameSpan.parentElement.querySelector('.task-loading-spinner')) {
                        const spinner = document.createElement('span');
                        spinner.className = 'task-loading-spinner';
                        spinner.title = 'Loading...';
                        taskNameSpan.parentElement.appendChild(spinner);
                    }

                    // Check if background loading is in progress
                    const isBackgroundLoading = window.backgroundLoadingInProgress;
                    
                    // If task has cached content (notes, comments, or subtasks), show it immediately
                    const hasCachedContent = (task.notes && task.notes.trim().length > 0) || 
                                            (task.html_notes && task.html_notes.trim().length > 0) ||
                                            (task.comments && task.comments.length > 0) ||
                                            (task.subtasks && task.subtasks.length > 0);
                    
                    if (hasCachedContent) {
                        // Render cached content immediately
                        await renderTaskDetails(taskGid);
                    } else {
                        // No cached content, show loading indicator
                        detailsDiv.innerHTML = '<div class="loading-indicator" style="padding: 10px 0 10px 40px; color: #6c757d;"><div class="spinner" style="display: inline-block; width: 16px; height: 16px; margin-right: 8px;"></div>Loading...</div>';
                    }

                    // Track whether we need to load new data
                    let needsDataLoad = false;

                    // Load comments if not loaded (only for actual tasks, not projects/sections)
                    if (!task.comments && !task.isProject && !task.isSection && !task.isPlaceholder) {
                        await loadComments(taskGid);
                        needsDataLoad = true;
                    }

                    // Load subtasks if not loaded
                    if (!task.subtasksLoaded) {
                        const isAssignedToUser = task.assignee && task.assignee.gid === currentUserId;
                        await loadSubtasksFiltered(task.gid, isAssignedToUser);
                        needsDataLoad = true;
                    }

                    // Only re-render if we loaded new data OR if we didn't have cached content initially
                    if (needsDataLoad || !hasCachedContent) {
                        await renderTaskDetails(taskGid);
                    }
                    
                    // Remove loading state and spinner
                    tasksBeingLoaded.delete(taskGid);
                    const loadingSpinner = taskElement.querySelector('.task-loading-spinner');
                    if (loadingSpinner) {
                        loadingSpinner.remove();
                    }
                }
            }
            
            saveExpandStates();
        }

        async function renderTaskDetails(taskGid) {
            const task = allTasksMap.get(taskGid);
            const detailsDiv = document.getElementById('details-' + taskGid);
            if (!task || !detailsDiv) return;

            // Initialize comment display count if not set
            if (!task.commentsShown) {
                task.commentsShown = 3; // Show 3 most recent by default
            }

            let contentHtml = '';

            // Notes section
            if ((task.notes && task.notes.trim().length > 0) || (task.html_notes && task.html_notes.trim().length > 0)) {
                // Full rich text for expanded view
                let richTextContent;
                if (task.html_notes) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(task.html_notes, 'text/html');
                    richTextContent = doc.body.innerHTML;
                } else {
                    richTextContent = linkifyHTML(task.notes || '');
                }
                
                // Stripped HTML for collapsed view (preserves links, lists, but removes styling)
                const collapsedContent = task.html_notes ? stripHtmlStyling(task.html_notes) : linkifyHTML(task.notes || '');
                
                // Always start collapsed (expansion state is not persisted)
                task.notesExpanded = false;
                
                contentHtml += `
                    <div class="notes-container" style="padding-left: 5px;">
                        <strong>Notes:</strong>
                        <div style="position: relative; margin-top: 5px;">
                            <button class="btn-edit" onclick="editTaskNotes(event, '${task.gid}')" style="position: absolute; top: 10px; right: 10px; z-index: 10;">Edit</button>
                            <div id="notes-${task.gid}" class="notes-content ${task.notesExpanded ? '' : 'collapsed'}" style="padding: 10px; padding-top: 40px; background: white; border-radius: 4px; margin-bottom: 0;">${task.notesExpanded ? richTextContent : collapsedContent}</div>
                        </div>
                        <button class="show-more-btn" onclick="toggleNotesExpansion(event, '${task.gid}')" style="display: none;">${task.notesExpanded ? 'Show Less' : 'Show More'}</button>
                    </div>
                `;
            }

            // Comments section with pagination
            if (task.comments && task.comments.length > 0) {
                contentHtml += '<div style="padding-left: 5px; margin-top: 15px; margin-bottom: 15px;"><h4>Comments</h4>';
                
                // Sort comments by date (oldest first for chronological display)
                const sortedComments = [...task.comments].sort((a, b) => 
                    new Date(a.created_at) - new Date(b.created_at)
                );
                
                const totalComments = sortedComments.length;
                const commentsToShow = Math.min(task.commentsShown, totalComments);
                const hasMoreComments = commentsToShow < totalComments;
                
                // Show "earlier comments" link if there are more
                if (hasMoreComments) {
                    const hiddenCount = totalComments - commentsToShow;
                    contentHtml += `
                        <div style="margin-bottom: 10px;">
                            <a href="#" onclick="showEarlierComments(event, '${taskGid}'); return false;" 
                               style="color: #667eea; text-decoration: none; font-size: 0.9em;">
                                ‚Üë Show ${Math.min(5, hiddenCount)} earlier comment${Math.min(5, hiddenCount) > 1 ? 's' : ''}
                            </a>
                        </div>
                    `;
                }
                
                // Calculate which comments to display
                // Skip the oldest (totalComments - commentsToShow) and show the rest
                const commentsToDisplay = sortedComments.slice(totalComments - commentsToShow);
                
                // Display comments in chronological order
                commentsToDisplay.forEach(comment => {
                    // Rich text for expanded view
                    const richCommentText = comment.html_text || linkifyHTML(comment.text);
                    // Stripped HTML for collapsed view (preserves links, lists, but removes styling)
                    const collapsedCommentText = comment.html_text ? stripHtmlStyling(comment.html_text) : linkifyHTML(comment.text);
                    
                    // Always start collapsed (expansion state is not persisted)
                    comment.expanded = false;
                    
                    // Only show edit/delete buttons if current user created the comment
                    const isOwnComment = comment.created_by.gid === currentUserId;
                    const actionButtons = isOwnComment ? `
                        <div>
                            <button class="btn-edit" onclick="editComment(event, '${taskGid}', '${comment.gid}')">Edit</button>
                            <button class="btn-delete" onclick="deleteComment(event, '${taskGid}', '${comment.gid}')">Delete</button>
                        </div>
                    ` : '';
                    
                    contentHtml += `
                        <div class="comment" style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 4px; position: relative;">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div>
                                    <div style="font-weight: 600; font-size: 0.9em;">${escapeHtml(comment.created_by.name)}</div>
                                    <div style="color: #6c757d; font-size: 0.85em; margin-bottom: 5px;">${new Date(comment.created_at).toLocaleString()}</div>
                                </div>
                                ${actionButtons}
                            </div>
                            <div id="comment-content-${comment.gid}" class="comment-content ${comment.expanded ? '' : 'collapsed'}" style="background: #f8f9fa; border-radius: 4px; margin-top: 5px; padding: 10px;">${comment.expanded ? richCommentText : collapsedCommentText}</div>
                            <button class="show-more-btn" onclick="toggleCommentExpansion(event, '${taskGid}', '${comment.gid}')" style="display: none;">${comment.expanded ? 'Show Less' : 'Show More'}</button>
                            <div id="comment-edit-${comment.gid}" style="display: none;"></div>
                        </div>
                    `;
                });
                
                contentHtml += '</div>';
            }
            
            // Add comment section (only for actual tasks, not projects/sections)
            if (!task.isProject && !task.isSection && !task.isPlaceholder) {
                contentHtml += `
                    <div style="padding-left: 5px; margin-bottom: 15px;">
                        <div id="new-comment-${taskGid}" style="display: none; margin-top: 10px;">
                            <div class="editor-container">
                                <div id="comment-editor-${taskGid}"></div>
                            </div>
                            <div style="margin-top: 8px;">
                                <button class="btn-edit" onclick="saveComment('${taskGid}')" style="opacity: 1; pointer-events: auto;">Add Comment</button>
                                <button class="btn-secondary" onclick="cancelComment('${taskGid}')" style="margin-left: 8px;">Cancel</button>
                            </div>
                        </div>
                        <button class="btn-edit" id="add-comment-btn-${taskGid}" onclick="showCommentBox('${taskGid}')" style="margin-top: 10px; opacity: 1; pointer-events: auto;">Add Comment</button>
                    </div>
                `;
            }

            detailsDiv.innerHTML = contentHtml;

            // Render subtasks if they exist
            if (task.subtasks && task.subtasks.length > 0) {
                const level = parseInt(detailsDiv.closest('.task-item').style.marginLeft || '0') / 40;
                task.subtasks.forEach(subtask => {
                    const subtaskElement = renderTask(subtask, level + 1);
                    detailsDiv.appendChild(subtaskElement);
                });
            }

            // Check if Show More buttons are needed after DOM is updated
            setTimeout(() => checkAndUpdateShowMoreButtons(), 0);
        }

        function checkAndUpdateShowMoreButtons() {
            // Check all notes and comments to see if they actually overflow
            document.querySelectorAll('.notes-content.collapsed, .comment-content.collapsed').forEach(element => {
                const maxHeight = parseFloat(getComputedStyle(element).maxHeight);
                const actualHeight = element.scrollHeight;
                
                // Find the associated show more button (next sibling)
                const showMoreBtn = element.nextElementSibling;
                
                // Determine if content actually overflows
                const hasOverflow = actualHeight > maxHeight + 25;
                
                // Show/hide button based on overflow
                if (showMoreBtn && showMoreBtn.classList.contains('show-more-btn')) {
                    if (hasOverflow) {
                        showMoreBtn.style.display = 'inline-block';
                        element.classList.add('collapsed'); // Ensure collapsed class is present
                    } else {
                        showMoreBtn.style.display = 'none';
                        // Add a class to hide gradient but keep line-height
                        element.classList.add('no-gradient');
                    }
                }
            });
        }

        async function toggleNotesExpansion(event, taskGid) {
            event.preventDefault();
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            // Toggle expansion state
            task.notesExpanded = !task.notesExpanded;
            
            const notesDiv = document.getElementById(`notes-${taskGid}`);
            const button = event.target;
            
            if (!notesDiv) return;
            
            if (task.notesExpanded) {
                // Expand: show rich text
                notesDiv.classList.remove('collapsed');
                let richTextContent;
                if (task.html_notes) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(task.html_notes, 'text/html');
                    richTextContent = doc.body.innerHTML;
                } else {
                    richTextContent = linkifyHTML(task.notes || '');
                }
                notesDiv.innerHTML = richTextContent;
                button.textContent = 'Show Less';
            } else {
                // Collapse: show stripped HTML (preserves links, removes styling)
                notesDiv.classList.add('collapsed');
                const collapsedContent = task.html_notes ? stripHtmlStyling(task.html_notes) : linkifyHTML(task.notes || '');
                notesDiv.innerHTML = collapsedContent;
                button.textContent = 'Show More';
            }
        }

        async function toggleCommentExpansion(event, taskGid, commentGid) {
            event.preventDefault();
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            if (!task || !task.comments) return;
            
            // Find the comment and toggle its expanded state
            const comment = task.comments.find(c => c.gid === commentGid);
            if (!comment) return;
            
            comment.expanded = !comment.expanded;
            
            const commentDiv = document.getElementById(`comment-content-${commentGid}`);
            const button = event.target;
            
            if (!commentDiv) return;
            
            if (comment.expanded) {
                // Expand: show rich text
                commentDiv.classList.remove('collapsed');
                const richCommentText = comment.html_text || linkifyHTML(comment.text);
                commentDiv.innerHTML = richCommentText;
                button.textContent = 'Show Less';
            } else {
                // Collapse: show stripped HTML (preserves links, removes styling)
                commentDiv.classList.add('collapsed');
                const collapsedCommentText = comment.html_text ? stripHtmlStyling(comment.html_text) : linkifyHTML(comment.text);
                commentDiv.innerHTML = collapsedCommentText;
                button.textContent = 'Show More';
            }
        }

        async function showEarlierComments(event, taskGid) {
            event.preventDefault();
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            // Increase by 5 comments
            task.commentsShown = (task.commentsShown || 3) + 5;
            
            // Re-render task details
            await renderTaskDetails(taskGid);
        }
        
        let commentEditor = null;
        
        function showCommentBox(taskGid) {
            const editorContainer = document.getElementById(`comment-editor-${taskGid}`);
            
            // Clear any existing content in the editor container
            editorContainer.innerHTML = '';
            
            document.getElementById(`new-comment-${taskGid}`).style.display = 'block';
            document.getElementById(`add-comment-btn-${taskGid}`).style.display = 'none';
            
            // Clean up existing editor if present
            if (commentEditor) {
                commentEditor.container = null;
                commentEditor = null;
            }
            
            // Initialize fresh Quill editor
            commentEditor = new Quill(`#comment-editor-${taskGid}`, {
                theme: 'snow',
                modules: {
                    toolbar: [
                        ['bold', 'italic', 'underline', 'strike'],
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                        ['link'],
                        ['clean']
                    ]
                },
                placeholder: 'Write a comment...'
            });
            
            commentEditor.focus();
        }
        
        async function cancelComment(taskGid) {
            if (commentEditor) {
                commentEditor.container = null;
                commentEditor = null;
            }
            
            // Re-render to reset the UI completely
            await renderTaskDetails(taskGid);
        }
        
        async function saveComment(taskGid) {
            if (!commentEditor) return;
            
            const commentText = commentEditor.getText().trim();
            
            if (!commentText) {
                showToast('Please enter a comment', 'error');
                return;
            }
            
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}/stories`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { text: commentText } })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to add comment');
                }
                
                // Clean up editor
                commentEditor.container = null;
                commentEditor = null;
                
                // Reload comments
                const task = allTasksMap.get(taskGid);
                task.comments = null; // Clear to force reload
                await loadComments(taskGid);
                
                // Re-render
                await renderTaskDetails(taskGid);
                
                showToast('Comment added successfully!', 'success', 2000);
                
            } catch (error) {
                showToast('Failed to add comment: ' + error.message, 'error');
            }
        }
        
        let editingCommentEditor = null;
        
        async function editComment(event, taskGid, commentGid) {
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            const comment = task.comments.find(c => c.gid === commentGid);
            if (!comment) return;
            
            // Hide content, show editor
            document.getElementById(`comment-content-${commentGid}`).style.display = 'none';
            const editorDiv = document.getElementById(`comment-edit-${commentGid}`);
            editorDiv.style.display = 'block';
            editorDiv.innerHTML = `
                <div class="editor-container" style="margin-top: 10px;">
                    <div id="edit-comment-editor-${commentGid}"></div>
                </div>
                <div style="margin-top: 8px;">
                    <button class="btn-edit" style="opacity: 1; pointer-events: auto;" onclick="saveCommentEdit('${taskGid}', '${commentGid}')">Save</button>
                    <button class="btn-secondary" onclick="cancelCommentEdit('${commentGid}')" style="margin-left: 8px;">Cancel</button>
                </div>
            `;
            
            // Initialize editor with existing content
            if (editingCommentEditor) {
                editingCommentEditor.container = null;
            }
            
            editingCommentEditor = new Quill(`#edit-comment-editor-${commentGid}`, {
                theme: 'snow',
                modules: {
                    toolbar: [
                        ['bold', 'italic', 'underline', 'strike'],
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                        ['link'],
                        ['clean']
                    ]
                }
            });
            
            // Load existing comment text
            const commentText = comment.text || '';
            editingCommentEditor.setText(commentText);
            editingCommentEditor.focus();
        }
        
        function cancelCommentEdit(commentGid) {
            document.getElementById(`comment-content-${commentGid}`).style.display = 'block';
            document.getElementById(`comment-edit-${commentGid}`).style.display = 'none';
            if (editingCommentEditor) {
                editingCommentEditor.container = null;
                editingCommentEditor = null;
            }
        }
        
        async function saveCommentEdit(taskGid, commentGid) {
            if (!editingCommentEditor) return;
            
            const commentText = editingCommentEditor.getText().trim();
            
            if (!commentText) {
                showToast('Comment cannot be empty', 'error');
                return;
            }
            
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/stories/${commentGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { text: commentText } })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to update comment');
                }
                
                // Clean up editor
                editingCommentEditor.container = null;
                editingCommentEditor = null;
                
                // Reload comments
                const task = allTasksMap.get(taskGid);
                task.comments = null;
                await loadComments(taskGid);
                
                // Re-render
                await renderTaskDetails(taskGid);
                
                showToast('Comment updated successfully!', 'success', 2000);
                
            } catch (error) {
                showToast('Failed to update comment: ' + error.message, 'error');
            }
        }
        
        async function deleteComment(event, taskGid, commentGid) {
            event.stopPropagation();
            
            if (!confirm('Are you sure you want to delete this comment?')) {
                return;
            }
            
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/stories/${commentGid}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`
                    }
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to delete comment');
                }
                
                // Reload comments
                const task = allTasksMap.get(taskGid);
                task.comments = null;
                await loadComments(taskGid);
                
                // Re-render
                await renderTaskDetails(taskGid);
                
                showToast('Comment deleted successfully!', 'success', 2000);
                
            } catch (error) {
                showToast('Failed to delete comment: ' + error.message, 'error');
            }
        }

        async function loadComments(taskGid) {
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}/stories?opt_fields=type,text,html_text,created_at,created_by,created_by.name`, {
                    headers: { 'Authorization': `Bearer ${personalAccessToken}` }
                });

                if (!response.ok) return;

                const data = await response.json();
                const task = allTasksMap.get(taskGid);
                
                task.comments = data.data.filter(story => 
                    story.type === 'comment' && (story.text || story.html_text)
                );
            } catch (error) {
                console.error('Error loading comments:', error);
            }
        }

        function getIncompleteSubtasks(task) {
            const incomplete = [];
            if (!task || !task.subtasks || task.subtasks.length === 0) {
                return incomplete;
            }
            
            for (const subtask of task.subtasks) {
                if (!subtask.completed) {
                    incomplete.push(subtask);
                }
                // Recursively check subtask's subtasks
                const childIncomplete = getIncompleteSubtasks(subtask);
                incomplete.push(...childIncomplete);
            }
            
            return incomplete;
        }

        function showSubtaskCompletionModal(taskGid, incompleteCount) {
            const task = allTasksMap.get(taskGid);
            const content = `
                <p>This task has <strong>${incompleteCount} incomplete subtask${incompleteCount > 1 ? 's' : ''}</strong>.</p>
                <p>Would you like to mark ${incompleteCount > 1 ? 'them' : 'it'} as complete as well?</p>
            `;
            const buttons = [
                {
                    text: 'Complete Task Only',
                    onclick: `completeTaskOnly('${taskGid}')`
                },
                {
                    text: 'Complete All',
                    onclick: `completeTaskAndSubtasks('${taskGid}')`
                }
            ];
            showGenericModal('Complete Task with Subtasks?', content, buttons);
        }

        async function completeTaskOnly(taskGid) {
            closeGenericModal();
            await markTaskComplete(taskGid, false);
        }

        async function completeTaskAndSubtasks(taskGid) {
            closeGenericModal();
            await markTaskComplete(taskGid, true);
        }

        async function markTaskComplete(taskGid, includeSubtasks) {
            const task = allTasksMap.get(taskGid);
            
            try {
                // Mark main task complete
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { completed: true } })
                });

                if (!response.ok) throw new Error('Failed to update task');

                task.completed = true;

                // Update UI for main task
                const taskElement = document.querySelector(`[data-task-id="${taskGid}"]`);
                if (taskElement) {
                    updateTaskCompletionUI(taskElement, task, true);
                }

                // Mark all subtasks complete if requested
                let completedSubtaskCount = 0;
                if (includeSubtasks) {
                    const incompleteSubtasks = getIncompleteSubtasks(task);
                    completedSubtaskCount = incompleteSubtasks.length;
                    for (const subtask of incompleteSubtasks) {
                        await markSubtaskComplete(subtask.gid);
                    }
                }

                showToast(`Task${completedSubtaskCount > 0 ? ' and subtasks' : ''} marked as complete`, 'success', 2000);

                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });

            } catch (error) {
                // Revert checkbox on error
                const taskElement = document.querySelector(`[data-task-id="${taskGid}"]`);
                const checkbox = taskElement?.querySelector('.task-checkbox');
                if (checkbox) checkbox.checked = false;
                showToast('Failed to update task: ' + error.message, 'error');
            }
        }

        async function markSubtaskComplete(subtaskGid) {
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${subtaskGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { completed: true } })
                });

                if (!response.ok) throw new Error('Failed to update subtask');

                const subtask = allTasksMap.get(subtaskGid);
                if (subtask) {
                    subtask.completed = true;
                    
                    // Update UI if subtask is visible
                    const subtaskElement = document.querySelector(`[data-task-id="${subtaskGid}"]`);
                    if (subtaskElement) {
                        updateTaskCompletionUI(subtaskElement, subtask, true);
                    }
                }
            } catch (error) {
                console.error(`Failed to complete subtask ${subtaskGid}:`, error);
            }
        }

        function updateTaskCompletionUI(taskElement, task, completed) {
            const taskName = taskElement.querySelector('.task-name');
            const dueDateButton = taskElement.querySelector('.due-date');
            const checkbox = taskElement.querySelector('.task-checkbox');
            
            if (completed) {
                taskElement.classList.add('completed');
                if (taskName) taskName.classList.add('completed');
                if (checkbox) checkbox.checked = true;
                
                // Remove overdue styling
                if (dueDateButton) {
                    dueDateButton.classList.remove('overdue');
                }
                
                // Auto-collapse completed task
                const detailsDiv = document.getElementById('details-' + task.gid);
                const expandIcon = taskElement.querySelector('.expand-icon');
                if (detailsDiv && detailsDiv.style.display !== 'none') {
                    detailsDiv.style.display = 'none';
                    if (expandIcon) expandIcon.textContent = '‚ñ∂';
                    expandStates[task.gid] = false;
                    saveExpandStates();
                }
            } else {
                taskElement.classList.remove('completed');
                if (taskName) taskName.classList.remove('completed');
                if (checkbox) checkbox.checked = false;
                
                // Re-check if task is overdue
                if (dueDateButton && task.due_on) {
                    const dueDate = new Date(task.due_on);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    if (dueDate < today) {
                        dueDateButton.classList.add('overdue');
                    }
                }
            }
            
            // Update parent non-tasks styling
            let currentParent = task.parent;
            while (currentParent) {
                const parentTask = allTasksMap.get(currentParent.gid);
                if (parentTask && (parentTask.isSection || parentTask.isProject || parentTask.isPlaceholder)) {
                    const parentElement = document.querySelector(`[data-task-id="${currentParent.gid}"]`);
                    if (parentElement) {
                        const allDescendantsComplete = areAllDescendantsComplete(parentTask);
                        const parentTaskName = parentElement.querySelector('.task-name');
                        
                        if (allDescendantsComplete) {
                            parentElement.classList.add('completed');
                            if (parentTaskName) parentTaskName.classList.add('completed');
                        } else {
                            parentElement.classList.remove('completed');
                            if (parentTaskName) parentTaskName.classList.remove('completed');
                        }
                    }
                }
                currentParent = parentTask ? parentTask.parent : null;
            }
        }

        async function toggleTaskCompletion(event, taskGid) {
            event.stopPropagation();
            const checkbox = event.target;
            const completed = checkbox.checked;

            // If marking complete and task has incomplete subtasks, prompt user
            if (completed) {
                const task = allTasksMap.get(taskGid);
                const incompleteSubtasks = getIncompleteSubtasks(task);
                
                if (incompleteSubtasks.length > 0) {
                    // Uncheck checkbox temporarily until user decides
                    checkbox.checked = false;
                    
                    // Show modal asking if user wants to complete subtasks too
                    showSubtaskCompletionModal(taskGid, incompleteSubtasks.length);
                    return;
                }
            }

            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { completed } })
                });

                if (!response.ok) throw new Error('Failed to update task');

                const task = allTasksMap.get(taskGid);
                task.completed = completed;

                const taskElement = checkbox.closest('.task-item');
                updateTaskCompletionUI(taskElement, task, completed);

                showToast(`Task marked as ${completed ? 'complete' : 'incomplete'}`, 'success', 2000);

                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });

            } catch (error) {
                checkbox.checked = !completed;
                showToast('Failed to update task: ' + error.message, 'error');
            }
        }

        async function editTaskNotes(event, taskGid) {
            event.stopPropagation();
            const task = allTasksMap.get(taskGid);
            const detailsDiv = document.getElementById('details-' + taskGid);
            
            if (detailsDiv.style.display === 'none') {
                detailsDiv.style.display = 'block';
            }

            if (activeEditor) {
                activeEditor.container = null;
            }

            const editorId = 'editor-' + taskGid;
            detailsDiv.innerHTML = `
                <div class="editor-container">
                    <div id="${editorId}"></div>
                </div>
                <div class="editor-actions">
                    <button class="btn-edit" onclick="saveTaskNotes('${taskGid}')" style="opacity: 1; pointer-events: auto;">Save</button>
                    <button class="btn-secondary" onclick="cancelEdit('${taskGid}')">Cancel</button>
                </div>
            `;

            activeEditor = new Quill('#' + editorId, {
                theme: 'snow',
                modules: {
                    toolbar: [
                        [{ 'header': [1, 2, 3, false] }],
                        ['bold', 'italic', 'underline', 'strike'],
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                        [{ 'color': [] }, { 'background': [] }],
                        ['link', 'code-block'],
                        ['clean']
                    ]
                }
            });

            // Use html_notes if available (includes proper formatting)
            if (task.html_notes) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(task.html_notes, 'text/html');
                let content = doc.body.innerHTML;
                
                // Convert line breaks to paragraphs for Quill
                // Each line becomes a paragraph to match how it displays with pre-line
                const lines = content.split(/\n/);
                const paragraphs = lines.map(line => {
                    const trimmed = line.trim();
                    // Empty lines become empty paragraphs (for spacing)
                    return '<p>' + (trimmed || '<br>') + '</p>';
                }).join('');
                
                activeEditor.clipboard.dangerouslyPasteHTML(paragraphs);
            } else if (task.notes) {
                activeEditor.clipboard.dangerouslyPasteHTML(task.notes);
            }
        }

        async function saveTaskNotes(taskGid) {
            if (!activeEditor) return;

            // Get the HTML from Quill
            const htmlNotes = activeEditor.root.innerHTML;
            
            // Also get plain text version as fallback
            const plainNotes = activeEditor.getText();

            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { notes: plainNotes } })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to save notes');
                }

                const task = allTasksMap.get(taskGid);
                task.notes = plainNotes;
                task.html_notes = htmlNotes;

                activeEditor = null;
                renderTaskDetails(taskGid);
                
                showToast('Task notes saved successfully!', 'success', 2000);

                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });

            } catch (error) {
                showToast('Failed to save notes: ' + error.message, 'error');
            }
        }

        function cancelEdit(taskGid) {
            activeEditor = null;
            const task = allTasksMap.get(taskGid);
            if (task.comments === null) {
                document.getElementById('details-' + taskGid).style.display = 'none';
            } else {
                renderTaskDetails(taskGid);
            }
        }

        async function renameTask(event, taskGid) {
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            const newName = prompt('Enter new task name:', task.name);
            if (!newName || newName.trim() === '' || newName === task.name) return;
            
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { name: newName.trim() } })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to rename task');
                }
                
                // Update local cache
                task.name = newName.trim();
                
                // Re-render the task
                const taskElement = document.querySelector(`[data-task-id="${taskGid}"]`);
                if (taskElement) {
                    const level = parseInt(taskElement.style.marginLeft || '0') / 5;
                    const isRoot = !task.parent;
                    const newElement = renderTask(task, level, isRoot);
                    taskElement.replaceWith(newElement);
                }
                
                showToast('Task renamed successfully!', 'success', 2000);
                
                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });
                
            } catch (error) {
                showToast('Failed to rename task: ' + error.message, 'error');
            }
        }

        async function createSubtask(event, parentGid) {
            event.stopPropagation();
            
            const taskName = prompt('Enter new subtask name:');
            if (!taskName || taskName.trim() === '') return;
            
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${parentGid}/subtasks`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        data: { 
                            name: taskName.trim(),
                            workspace: WORKSPACE_ID
                        } 
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to create subtask');
                }
                
                const result = await response.json();
                const newSubtask = result.data;
                
                // Add to parent's subtasks
                const parent = allTasksMap.get(parentGid);
                if (!parent.subtasks) parent.subtasks = [];
                
                // Add full subtask info to map
                newSubtask.parent = { gid: parentGid };
                allTasksMap.set(newSubtask.gid, newSubtask);
                parent.subtasks.push(newSubtask);
                
                // Expand parent if not already expanded
                if (!expandStates[parentGid]) {
                    expandStates[parentGid] = true;
                    saveExpandStates();
                }
                
                // Re-render parent task
                const taskElement = document.querySelector(`[data-task-id="${parentGid}"]`);
                if (taskElement) {
                    const level = parseInt(taskElement.style.marginLeft || '0') / 5;
                    const isRoot = !parent.parent;
                    const newElement = renderTask(parent, level, isRoot);
                    taskElement.replaceWith(newElement);
                }
                
                showToast('Subtask created successfully!', 'success', 2000);
                
                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });
                
            } catch (error) {
                showToast('Failed to create subtask: ' + error.message, 'error');
            }
        }

        async function setDueDate(event, taskGid) {
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            // Create a temporary input element for date picking
            const input = document.createElement('input');
            input.type = 'date';
            input.value = task.due_on || '';
            input.style.position = 'fixed';
            input.style.top = event.clientY + 'px';
            input.style.left = event.clientX + 'px';
            input.style.zIndex = '10000';
            
            document.body.appendChild(input);
            
            // Handle date selection
            const handleDateChange = async () => {
                const dateInput = input.value;
                
                // Remove event listeners first
                input.removeEventListener('change', handleDateChange);
                input.removeEventListener('blur', handleCancel);
                
                // Remove input if still in DOM
                if (document.body.contains(input)) {
                    document.body.removeChild(input);
                }
                
                // If no date selected and had a date before, ask if they want to remove it
                if (!dateInput && task.due_on) {
                    if (!confirm('Remove the due date?')) return;
                }
                
                // If no change, just return
                if (dateInput === task.due_on || (!dateInput && !task.due_on)) return;
                
                await saveDueDate(taskGid, dateInput);
            };
            
            // Handle cancel
            const handleCancel = () => {
                // Remove event listeners first
                input.removeEventListener('change', handleDateChange);
                input.removeEventListener('blur', handleCancel);
                
                // Remove input if still in DOM
                if (document.body.contains(input)) {
                    document.body.removeChild(input);
                }
            };
            
            input.addEventListener('change', handleDateChange);
            input.addEventListener('blur', handleCancel);
            
            // Open the date picker
            input.focus();
            input.showPicker();
        }
        
        async function saveDueDate(taskGid, dateInput) {
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            // Clean up the date input
            const cleanDate = dateInput ? dateInput.trim() : '';
            
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        data: { 
                            due_on: cleanDate || null 
                        } 
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to set due date');
                }
                
                // Update local cache
                if (cleanDate) {
                    task.due_on = cleanDate;
                } else {
                    delete task.due_on;
                }
                
                // Re-render the task
                const taskElement = document.querySelector(`[data-task-id="${taskGid}"]`);
                if (taskElement) {
                    const level = parseInt(taskElement.style.marginLeft || '0') / 5;
                    const isRoot = !task.parent;
                    const newElement = renderTask(task, level, isRoot);
                    taskElement.replaceWith(newElement);
                }
                
                const message = dateInput.trim() ? 'Due date set successfully!' : 'Due date removed!';
                showToast(message, 'success', 2000);
                
                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });
                
            } catch (error) {
                showToast('Failed to set due date: ' + error.message, 'error');
            }
        }

        // Generic modal system - reusable for any modal content
        function showGenericModal(title, content, buttons = []) {
            const modal = document.getElementById('genericModal');
            const modalContent = document.getElementById('genericModalContent');
            
            let buttonsHtml = '';
            if (buttons.length > 0) {
                buttonsHtml = '<div class="modal-footer">';
                buttons.forEach((btn, index) => {
                    const btnClass = btn.class || (index === buttons.length - 1 ? 'btn-edit' : 'btn-secondary');
                    const btnStyle = btnClass === 'btn-edit' ? 'opacity: 1; pointer-events: auto;' : '';
                    buttonsHtml += `<button class="${btnClass}" onclick="${btn.onclick}" style="${btnStyle}">${btn.text}</button>`;
                });
                buttonsHtml += '</div>';
            } else {
                // Default close button
                buttonsHtml = '<div class="modal-footer"><button onclick="closeGenericModal()">Close</button></div>';
            }
            
            modalContent.innerHTML = `
                <h2>${title}</h2>
                <div class="modal-body">
                    ${content}
                </div>
                ${buttonsHtml}
            `;
            
            modal.classList.add('active');
        }

        function closeGenericModal() {
            document.getElementById('genericModal').classList.remove('active');
        }

        function showInfoModal() {
            const info = window.taskDebugInfo || {};
            
            const content = `
                <div style="font-size: 1.1em; line-height: 1.8;">
                    <p><strong>üìä Task Statistics:</strong></p>
                    <ul style="list-style: none; padding-left: 20px;">
                        <li>‚Ä¢ Showing: <strong>${info.afterFilters || 0} root items</strong></li>
                        <li>‚Ä¢ Total tasks: <strong>${info.totalTasks || 0}</strong></li>
                        <li>‚Ä¢ Completed: <strong>${info.completedTasks || 0}</strong></li>
                        <li>‚Ä¢ Remaining: <strong>${info.remainingTasks || 0}</strong></li>
                    </ul>
                    
                    <p style="margin-top: 20px;"><strong>üîç Active Filters:</strong></p>
                    <ul style="list-style: none; padding-left: 20px;">
                        <li>‚Ä¢ Completion: <strong>${info.completionFilter || 'N/A'}</strong></li>
                        <li>‚Ä¢ Date range: <strong>${info.dateFilter || 'N/A'}</strong></li>
                    </ul>
                    
                    <p style="margin-top: 20px;"><strong>üîÑ Data Source:</strong></p>
                    <ul style="list-style: none; padding-left: 20px;">
                        <li>‚Ä¢ <strong>${info.dataSource || 'Unknown'}</strong></li>
                    </ul>
                </div>
            `;
            
            showGenericModal('Task Information', content);
        }

        // Filter modal functions
        function showFilterModal() {
            const modal = document.getElementById('filterModal');
            modal.classList.add('active');

            // Set current values
            document.querySelector(`input[name="completionFilter"][value="${filterState.completion}"]`).checked = true;
            document.getElementById('dateRangeType').value = filterState.dateRange;
            
            if (filterState.dateRange === 'custom') {
                document.getElementById('customDateRange').style.display = 'block';
                if (filterState.customStart) {
                    document.getElementById('startDate').value = filterState.customStart;
                }
                if (filterState.customEnd) {
                    document.getElementById('endDate').value = filterState.customEnd;
                }
            }
        }

        function closeFilterModal() {
            document.getElementById('filterModal').classList.remove('active');
        }

        function toggleCustomDateRange() {
            const rangeType = document.getElementById('dateRangeType').value;
            const customRange = document.getElementById('customDateRange');
            customRange.style.display = rangeType === 'custom' ? 'block' : 'none';
        }

        async function applyFilters() {
            // Get values
            const oldCompletion = filterState.completion;
            const oldDateRange = filterState.dateRange;
            
            filterState.completion = document.querySelector('input[name="completionFilter"]:checked').value;
            filterState.dateRange = document.getElementById('dateRangeType').value;
            filterState.parentFilter = document.getElementById('parentFilter').value;

            if (filterState.dateRange === 'custom') {
                filterState.customStart = document.getElementById('startDate').value;
                filterState.customEnd = document.getElementById('endDate').value;
            }

            saveFilterState();
            
            // Display filter badges immediately so user sees them right away
            displayFilterBadges();
            
            closeFilterModal();

            // Check if we need to reload from API
            // Only reload if completion or date filters changed (these affect what data we fetch)
            const needsAPIReload = (oldCompletion !== filterState.completion) || 
                                   (oldDateRange !== filterState.dateRange);
            
            if (needsAPIReload) {
                // These filters affect API queries, so we need to reload
                clearCache();
                await loadUserTasks();
            } else {
                // Just parent filter changed - re-display existing data
                displayTasks();
            }
        }

        function displayFilterBadges() {
            const badgesDiv = document.getElementById('filterBadges');
            badgesDiv.innerHTML = '';

            const chips = [];

            // Only show completion chip if not showing all tasks
            if (filterState.completion !== 'both') {
                const completionLabels = {
                    'uncompleted': 'Incomplete Only',
                    'completed': 'Completed Only'
                };
                chips.push({
                    label: completionLabels[filterState.completion],
                    onDelete: () => {
                        filterState.completion = 'both';
                        saveFilterState();
                        displayTasks();
                        displayFilterBadges();
                    }
                });
            }

            // Only show date chip if not showing all dates
            if (filterState.dateRange !== 'all') {
                const labels = {
                    'last7': 'Last 7 days',
                    'last30': 'Last 30 days',
                    'last90': 'Last 90 days',
                    'custom': 'Custom range'
                };
                chips.push({
                    label: labels[filterState.dateRange],
                    onDelete: async () => {
                        const oldDateRange = filterState.dateRange;
                        filterState.dateRange = 'all';
                        filterState.customStart = null;
                        filterState.customEnd = null;
                        saveFilterState();
                        
                        // Date filter affects API queries, so we need to reload
                        await loadUserTasks();
                        displayFilterBadges();
                    }
                });
            }

            // Only show parent chip if a parent filter is active
            if (filterState.parentFilter) {
                const parent = allTasksMap.get(filterState.parentFilter);
                if (parent) {
                    chips.push({
                        label: 'Project: ' + parent.name,
                        onDelete: () => {
                            filterState.parentFilter = '';
                            document.getElementById('parentFilter').value = '';
                            saveFilterState();
                            displayTasks();
                            displayFilterBadges();
                        }
                    });
                }
            }

            // Create chip elements
            chips.forEach(chip => {
                const chipDiv = document.createElement('div');
                chipDiv.className = 'filter-chip';
                
                const label = document.createElement('span');
                label.textContent = chip.label;
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'filter-chip-delete';
                deleteBtn.innerHTML = '√ó';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    // Remove chip immediately for instant feedback
                    chipDiv.remove();
                    // Then execute the delete handler
                    chip.onDelete();
                };
                deleteBtn.title = 'Remove filter';
                
                chipDiv.appendChild(label);
                chipDiv.appendChild(deleteBtn);
                badgesDiv.appendChild(chipDiv);
            });
        }

        // Utility functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function linkifyHTML(html) {
            const urlRegex = /(https?:\/\/[^\s<]+)/g;
            return html.replace(urlRegex, '<a href="$1" target="_blank" style="color: #667eea; text-decoration: underline;">$1</a>');
        }

        function stripHtmlStyling(html) {
            if (!html) return '';
            
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Remove all style attributes and certain formatting tags
            const elementsWithStyle = doc.querySelectorAll('[style]');
            elementsWithStyle.forEach(el => el.removeAttribute('style'));
            
            // Remove span, font, and other pure styling tags but keep their content
            const stylingTags = doc.querySelectorAll('span, font, div');
            stylingTags.forEach(el => {
                // Replace the element with its content
                const parent = el.parentNode;
                while (el.firstChild) {
                    parent.insertBefore(el.firstChild, el);
                }
                parent.removeChild(el);
            });
            
            // Keep semantic tags: a, ul, ol, li, p, strong, em, b, i, br
            // Everything else gets stripped but content preserved
            
            return doc.body.innerHTML;
        }

        function logout() {
            if (confirm('Are you sure you want to logout? This will clear your cached data.')) {
                clearPAT();
                clearWorkspaceId();
                clearCache();
                location.reload();
            }
        }

        // Initialize on page load
        // Close modals when clicking outside
        window.onclick = function(event) {
            const genericModal = document.getElementById('genericModal');
            const filterModal = document.getElementById('filterModal');
            
            if (event.target === genericModal) {
                closeGenericModal();
            }
            if (event.target === filterModal) {
                closeFilterModal();
            }
        };

        window.onload = function() {
            loadExpandStates();
            const savedToken = loadPAT();
            const savedWorkspaceId = loadWorkspaceId();
            if (savedToken) {
                personalAccessToken = savedToken;
                WORKSPACE_ID = savedWorkspaceId; // May be null, will be fetched during auth if needed
                authenticateAndLoad();
            }
        };
    </script>
</body>
</html>
