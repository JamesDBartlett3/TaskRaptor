<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TaskRaptor | Devour your Asana tasks like a Bird of Prey</title>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js" 
        integrity="sha384-0zm5QqnR2gL4GY5AwreU3xp5AEGWqkdbamrRLeXwWwepp4JqmPRawLJFD8Cm802W" 
        crossorigin="anonymous">
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #2c7873 0%, #1a4f4a 100%);
            min-height: 100vh;
            padding: 20px;
            min-width: 550px;
        }
        body.debug-mode {
            background: linear-gradient(135deg, #c0392b 0%, #8e2a1f 100%);
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            overflow: visible;
        }
        .header {
            background: linear-gradient(135deg, #2c7873 0%, #1a4f4a 100%);
            color: white;
            padding: 30px;
            display: flex;
            align-items: center;
            gap: 20px;
            border-radius: 12px 12px 0 0;
        }
        .header-logo {
            width: 120px;
            height: 120px;
            border-radius: 6px;
            flex-shrink: 0;
        }
        .header-content {
            flex: 1;
            text-align: center;
        }
        .header h1 {
            margin-bottom: 10px;
            font-size: 2em;
        }
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        .debug-indicator {
            display: none;
            color: #ff4444;
            font-weight: bold;
            font-size: 1.2em;
            margin: 5px 0;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .debug-indicator:hover {
            color: #ff6666;
            text-shadow: 0 0 15px rgba(255, 68, 68, 0.8);
            text-decoration: underline;
        }
        .enter-debug-mode {
            display: none;
            color: #ff8844;
            font-weight: bold;
            font-size: 1em;
            margin: 5px 0;
            text-shadow: 0 0 10px rgba(255, 136, 68, 0.5);
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .enter-debug-mode:hover {
            color: #ffaa66;
            text-shadow: 0 0 15px rgba(255, 136, 68, 0.8);
            text-decoration: underline;
        }
        .auth-section {
            padding: 40px;
            text-align: center;
        }
        .auth-section input {
            width: 100%;
            max-width: 500px;
            padding: 12px;
            margin: 10px 0;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
        }
        .auth-section button {
            padding: 12px 30px;
            background: #e67e22;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s;
        }
        .auth-section button:hover {
            background: #d35400;
        }
        .controls {
            padding: 20px 30px 20px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 20px;
            align-items: start;
            position: sticky;
            top: -1px;
            z-index: 1000;
            transition: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0);
            will-change: padding, box-shadow;
        }
        .controls.compact {
            padding: 10px 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        .controls.compact button .btn-text {
            display: none;
        }
        .controls.compact button,
        .controls.compact select {
            padding: 6px 10px;
            font-size: 0.85em;
        }
        .controls.compact .filter-chip {
            padding: 4px 8px;
            font-size: 0.8em;
        }
        .controls-logo {
            height: 40px;
            width: 40px;
            padding: 5px 3px;
            border-radius: 8px;
            width: 0;
            opacity: 0;
            overflow: hidden;
            transition: width 0.3s ease, opacity 0.3s ease, margin-right 0.3s ease;
        }
        /* Show logo when compact */
        .controls.compact .controls-logo {
            width: 40px;
            opacity: 1;
        }
        .controls-left {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        .controls-right {
            display: flex;
            flex-wrap: wrap-reverse;
            gap: 15px;
            align-items: center;
            justify-content: flex-end;
        }
        @media (max-width: 575px) {
            .controls-right {
                flex-direction: column-reverse;
                align-items: flex-end;
            }
        }
        .controls button, .controls select {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.2s ease;
        }
        .controls button .btn-text {
            display: inline;
        }
        .controls.compact button .btn-text {
            display: none;
        }
        .controls button:hover {
            background: #f8f9fa;
        }
        .filter-chip {
            display: inline-flex;
            align-items: center;
            background: #e0e0e0;
            color: #333;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 0.9em;
            gap: 8px;
            margin: 0 4px;
        }
        .filter-chip-delete {
            cursor: pointer;
            font-weight: bold;
            color: #666;
            background: none;
            border: none;
            padding: 0;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 1.1em;
            transition: background 0.2s;
        }
        .filter-chip-delete:hover {
            background: #bbb;
            color: #000;
        }
        /* Sort Buttons Row */
        .sort-buttons-row {
            display: flex;
            gap: 10px;
            align-items: center;
            width: 100%;
            margin-top: 10px;
        }
        .sort-toggle-btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            user-select: none;
            position: relative;
        }
        .sort-toggle-btn:hover {
            background: #f8f9fa;
            border-color: #2c7873;
        }
        /* Sort states */
        .sort-toggle-btn.sort-neutral {
            background: white;
            color: #666;
        }
        .sort-toggle-btn.sort-asc {
            background: #e8f4f3;
            color: #2c7873;
            border-color: #2c7873;
        }
        .sort-toggle-btn.sort-desc {
            background: #e8f4f3;
            color: #2c7873;
            border-color: #2c7873;
        }
        /* Sort indicator icons */
        .sort-indicator {
            font-size: 1.1em;
            line-height: 1;
            display: inline-block;
            width: 1em;
            text-align: center;
        }
        /* Sort priority subscript */
        .sort-priority {
            font-size: 0.7em;
            vertical-align: sub;
            font-weight: bold;
            color: #e67e22;
            margin-left: 2px;
        }
        /* Compact mode adjustments for sort buttons */
        .controls.compact .sort-buttons-row {
            margin-top: 5px;
        }
        .controls.compact .sort-toggle-btn {
            padding: 4px 8px;
            font-size: 0.85em;
        }
        .controls.compact .sort-toggle-btn .btn-text {
            display: none;
        }
        .summary {
            padding: 20px 30px;
            background: #e9ecef;
            font-size: 0.95em;
            color: #495057;
            display: none;
        }
        .progress-container {
            padding: 40px;
            text-align: center;
        }
        .progress-bar {
            width: 100%;
            max-width: 600px;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px auto;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2c7873 0%, #e67e22 100%);
            transition: width 0.3s;
            border-radius: 15px;
        }
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-weight: bold;
            font-size: 0.9em;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2c7873;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .content {
            padding: 30px;
        }
        .task-item {
            padding: 15px;
            border-left: 4px solid transparent;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            transition: all 0.2s;
        }
        .task-item:hover {
            background: #e9ecef;
            border-left-color: #2c7873;
        }
        .task-item.completed {
            opacity: 0.6;
        }
        .task-header {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            flex-wrap: wrap;
        }
        .task-header-main {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 1;
            min-width: 0;
        }
        .expand-icon {
            font-size: 0.8em;
            color: #6c757d;
            cursor: pointer;
            user-select: none;
            width: 20px;
            display: inline-block;
            flex-shrink: 0;
        }
        .task-checkbox {
            cursor: pointer;
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }
        .task-name {
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
            color: #333;
            font-size: 14px;
            max-width: 100%;
        }
        .task-name.completed {
            text-decoration: line-through;
            color: #6c757d;
        }
        .task-meta {
            display: inline-flex;
            gap: 10px;
            font-size: 0.85em;
            color: #6c757d;
            flex-shrink: 0;
            margin-left: 4px;
        }
        .task-header-buttons {
            display: flex;
            flex-direction: row-reverse;
            gap: 8px;
            flex-shrink: 0;
            margin-left: auto;
        }
        .due-date {
            padding: 2px 8px;
            background: #fff3cd;
            border-radius: 4px;
        }
        .due-date.overdue {
            background: #f8d7da;
            color: #721c24;
        }
        .breadcrumb {
            padding: 4px 0 8px 0;
            font-size: 0.80em;
            color: #6c757d;
            margin-bottom: 2px;
        }
        .breadcrumb-link {
            color: #6c757d;
            text-decoration: none;
            cursor: pointer;
            transition: color 0.2s;
        }
        .breadcrumb-link:hover {
            color: #495057;
            text-decoration: underline;
        }
        .task-details {
            margin-top: 15px;
            padding-left: 30px;
        }
        .btn-edit, .btn-delete, .btn-action {
            padding: 5px 12px;
            background: white;
            color: #495057;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            margin-left: 5px;
        }
        .btn-edit:hover, .btn-delete:hover, .btn-action:hover {
            background: #f8f9fa;
        }
        .btn-mark-all-complete:hover {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }
        .task-header:hover .btn-edit,
        .task-header:hover .btn-action,
        .comment:hover .btn-edit,
        .comment:hover .btn-delete,
        .notes-container:hover > div > .btn-edit {
            opacity: 1;
            pointer-events: auto;
        }
        .task-item.completed .due-date {
            opacity: 0;
            pointer-events: none;
        }
        .task-item.completed:hover .due-date {
            opacity: 1;
            pointer-events: auto;
        }
        .task-loading-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #2c7873;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 8px;
            vertical-align: middle;
        }
        .background-update-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #2c7873;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 8px;
            vertical-align: middle;
        }
        body:not(.background-loading) .background-update-spinner {
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Global spinner for all expanded tasks during background loading */
        .global-update-spinner {
            padding: 8px;
            color: #6c757d;
            font-size: 0.9em;
            border-bottom: 1px solid #dee2e6;
            margin-bottom: 10px;
            background: #f8f9fa;
        }
        .global-update-spinner::before {
            content: "";
            display: inline-block;
            width: 14px;
            height: 14px;
            margin-right: 6px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #2c7873;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            vertical-align: middle;
        }
        .editor-container {
            margin-top: 15px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
        }
        .editor-actions {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
        .notes-content p {
            margin: 0 0 10px 0;
            display: block;
        }
        .notes-content p:first-child {
            margin-top: 0;
        }
        .notes-content p:last-child {
            margin-bottom: 0;
        }
        .notes-content a {
            color: #2c7873;
            text-decoration: none;
        }
        .notes-content a:hover {
            text-decoration: underline;
        }
        /* Fix bullet point indentation */
        .notes-content ul,
        .notes-content ol,
        .comment-content ul,
        .comment-content ol {
            margin: 0 0 10px 0;
            padding-left: 30px;
        }
        .notes-content ul:first-child,
        .notes-content ol:first-child,
        .comment-content ul:first-child,
        .comment-content ol:first-child {
            margin-top: 0;
        }
        .notes-content ul:last-child,
        .notes-content ol:last-child,
        .comment-content ul:last-child,
        .comment-content ol:last-child {
            margin-bottom: 0;
        }
        .notes-content li,
        .comment-content li {
            margin: 5px 0;
        }
        .notes-content,
        .comment-content {
            line-height: 1.6;
        }
        .notes-content.collapsed,
        .comment-content.collapsed {
            max-height: 4.8em; /* 3 lines √ó 1.6 line-height */
            overflow: hidden;
            position: relative;
            box-sizing: content-box; /* Make max-height only apply to content, not padding */
        }
        .notes-content.collapsed::after,
        .comment-content.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3.2em;
            background: linear-gradient(to bottom, 
                rgba(255,255,255,0) 0%, 
                rgba(255,255,255,0.3) 25%,
                rgba(255,255,255,0.6) 50%, 
                rgba(255,255,255,0.85) 75%,
                rgba(255,255,255,1) 100%);
            pointer-events: none;
        }
        .notes-content.no-gradient::after,
        .comment-content.no-gradient::after {
            display: none;
        }
        .show-more-btn {
            color: #2c7873;
            background: none;
            border: none;
            padding: 5px 0;
            cursor: pointer;
            font-size: 0.9em;
            text-decoration: none;
        }
        .show-more-btn:hover {
            text-decoration: underline;
        }
        .comments-section {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
        .comment {
            padding: 10px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .comment-author {
            font-weight: bold;
            color: #2c7873;
            margin-bottom: 5px;
        }
        .comment-date {
            font-size: 0.8em;
            color: #6c757d;
            margin-bottom: 5px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
        }
        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideDown 0.3s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes slideDown {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .modal h2 {
            margin-bottom: 20px;
            color: #333;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #495057;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
        }
        .radio-group {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .radio-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .modal-body {
            margin: 20px 0;
        }
        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
        }
        .modal-footer button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            background: #e67e22;
            color: white;
        }
        .modal-footer button:hover {
            background: #d35400;
        }
        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        .modal-actions button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
        }
        .btn-primary {
            background: #e67e22;
            color: white;
        }
        .btn-primary:hover {
            background: #d35400;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #5a6268;
        }
        .toast {
            position: fixed;
            right: 20px;
            background: white;
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 12px;
            max-width: 400px;
            z-index: 2000;
            animation: slideIn 0.3s forwards;
            transition: top 0.3s ease;
        }
        .toast.hiding {
            animation: slideOut 0.3s forwards;
        }
        .toast.error { border-left: 4px solid #dc3545; }
        .toast.success { border-left: 4px solid #28a745; }
        .toast.info { border-left: 4px solid #17a2b8; }
        .toast.warning { border-left: 4px solid #ffc107; }
        .toast-close {
            margin-left: auto;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2em;
            color: #6c757d;
        }
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <img src="TaskRaptor.png" alt="TaskRaptor Logo" class="header-logo">
            <div class="header-content">
                <h1>TaskRaptor</h1>
                <a id="debugIndicator" class="debug-indicator" href="#" onclick="exitDebugMode(); return false;" title="Click to exit debug mode">DEBUG MODE: ON (Click to Exit)</a>
                <a id="enterDebugMode" class="enter-debug-mode" href="#" onclick="enterDebugMode(); return false;" title="Enable debug mode">üîç Click here to enter Debug Mode</a>
                <p>View and manage your assigned tasks from Asana with filtering, sorting, and caching</p>
            </div>
            <img src="TaskRaptor.png" alt="TaskRaptor Logo" class="header-logo">
        </div>

        <div id="authSection" class="auth-section">
            <h2>Connect to Asana</h2>
            <p style="margin: 20px 0;">Enter your Personal Access Token to get started</p>
            <input type="password" id="patInput" placeholder="Paste your Asana Personal Access Token here" />
            <br>
            <button onclick="authenticate()">Connect</button>
            <p style="margin-top: 20px; font-size: 0.9em; color: #666;">
                Get your token from: <a href="https://app.asana.com/0/my-apps" target="_blank">https://app.asana.com/0/my-apps</a>
            </p>
        </div>

        <div id="mainSection" style="display: none;">
            <div class="controls">
                <div class="controls-left">
                    <img src="TaskRaptor.png" alt="TaskRaptor" class="controls-logo">
                    <button onclick="showInfoModal()" title="Info"><span class="btn-icon">‚ÑπÔ∏è</span><span class="btn-text"> Info</span></button>
                    <button onclick="showFilterModal()" title="Filter & Sort"><span class="btn-icon">üîç</span><span class="btn-text"> Filter & Sort</span></button>
                    <div id="filterBadges"></div>
                </div>
                <div class="controls-right">
                    <button onclick="refreshData()" title="Refresh"><span class="btn-icon">üîÑ</span><span class="btn-text"> Refresh</span></button>
                    <button id="clearCacheBtn" onclick="localStorage.clear(); location.reload();" title="Clear Cache & Reload" style="background: #dc3545; display: none;"><span class="btn-icon">üóëÔ∏è</span><span class="btn-text"> Clear Cache</span></button>
                    <button onclick="logout()" title="Logout"><span class="btn-icon">üö™</span><span class="btn-text"> Logout</span></button>
                </div>
            </div>

            <div id="summary" class="summary"></div>

            <div id="progressSection" class="progress-container" style="display: none;">
                <div class="spinner"></div>
                <p id="progressMessage">Loading tasks...</p>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%;"></div>
                    <div id="progressText" class="progress-text">0%</div>
                </div>
            </div>

            <div id="content" class="content"></div>
        </div>
    </div>

    <!-- Generic Modal Container -->
    <div id="genericModal" class="modal">
        <div class="modal-content" id="genericModalContent">
            <!-- Content will be injected here -->
        </div>
    </div>

    <!-- Filter Modal -->
    <div id="filterModal" class="modal">
        <div class="modal-content">
            <h2>Filter & Sort</h2>
            
            <div class="form-group">
                <label>Completion Status</label>
                <div class="radio-group">
                    <label>
                        <input type="radio" name="completionFilter" value="incomplete" checked>
                        Incomplete
                    </label>
                    <label>
                        <input type="radio" name="completionFilter" value="completed">
                        Completed
                    </label>
                    <label>
                        <input type="radio" name="completionFilter" value="both">
                        All
                    </label>
                </div>
            </div>

            <div class="form-group">
                <label for="dateRangeType">Date Filter</label>
                <select id="dateRangeType" onchange="toggleCustomDateRange()">
                    <option value="last7">Last 7 days</option>
                    <option value="last30" selected>Last 30 days</option>
                    <option value="last90">Last 90 days</option>
                    <option value="custom">Custom range</option>
                    <option value="all">All time</option>
                </select>
            </div>

            <div id="customDateRange" class="form-group" style="display: none;">
                <label for="startDate">Start Date</label>
                <input type="date" id="startDate">
                <label for="endDate" style="margin-top: 10px;">End Date</label>
                <input type="date" id="endDate">
            </div>

            <div class="form-group">
                <label for="parentFilter">Filter by Parent Project</label>
                <select id="parentFilter">
                    <option value="">All Projects</option>
                </select>
            </div>

            <div class="form-group">
                <label>Sort By</label>
                <div class="sort-buttons-row">
                    <button class="sort-toggle-btn sort-neutral" data-sort-field="modified" data-sort-order="none" data-sort-priority="0" onclick="handleSortButtonClick(event, 'modified')" title="Sort by Last Modified">
                        <span class="sort-indicator">‚áÖ</span>
                        <span class="btn-text">Modified</span>
                        <span class="sort-priority" style="display:none;"></span>
                    </button>
                    <button class="sort-toggle-btn sort-neutral" data-sort-field="due_date" data-sort-order="none" data-sort-priority="0" onclick="handleSortButtonClick(event, 'due_date')" title="Sort by Due Date">
                        <span class="sort-indicator">‚áÖ</span>
                        <span class="btn-text">Due</span>
                        <span class="sort-priority" style="display:none;"></span>
                    </button>
                    <button class="sort-toggle-btn sort-neutral" data-sort-field="completed" data-sort-order="none" data-sort-priority="0" onclick="handleSortButtonClick(event, 'completed')" title="Sort by Status">
                        <span class="sort-indicator">‚áÖ</span>
                        <span class="btn-text">Status</span>
                        <span class="sort-priority" style="display:none;"></span>
                    </button>
                    <button class="sort-toggle-btn sort-neutral" data-sort-field="name" data-sort-order="none" data-sort-priority="0" onclick="handleSortButtonClick(event, 'name')" title="Sort by Name">
                        <span class="sort-indicator">‚áÖ</span>
                        <span class="btn-text">Name</span>
                        <span class="sort-priority" style="display:none;"></span>
                    </button>
                </div>
            </div>

            <div class="modal-actions">
                <button class="btn-secondary" onclick="closeFilterModal()">Cancel</button>
                <button class="btn-primary" onclick="applyFilters()">Apply Filters</button>
            </div>
        </div>
    </div>

    <script>
        // App version - update this with each release to invalidate old caches
        const APP_VERSION = '2025-12-15-v1';
        
        // Debug mode: Check for ?debug URL parameter
        const isDebugMode = new URLSearchParams(window.location.search).has('debug');
        
        // Custom logging function that only logs when debug mode is enabled
        function debugLog(...args) {
            if (isDebugMode) {
                console.log(...args);
            }
        }
        
        let WORKSPACE_ID = null;
        let personalAccessToken = '';
        let currentUserId = '';
        let allTasksMap = new Map();
        let rootItems = [];
        let activeEditor = null;
        let commentEditors = new Map();
        let cachedData = null;
        let allParents = new Set();
        let expandStates = {}; // Track expand/collapse state by task GID
        const tasksBeingLoaded = new Set(); // Track which tasks are currently loading
        
        // Filter state
        let filterState = {
            completion: 'incomplete',
            dateRange: 'last30',
            customStart: null,
            customEnd: null,
            parentFilter: ''
        };

        // Load filter state from localStorage
        function loadFilterState() {
            const saved = localStorage.getItem('taskraptor_filters');
            if (saved) {
                filterState = JSON.parse(saved);
                // Migration: Convert old 'uncompleted' value to 'incomplete'
                if (filterState.completion === 'uncompleted') {
                    filterState.completion = 'incomplete';
                    saveFilterState(); // Save the migrated value
                }
                debugLog('Loaded filter state from localStorage:', filterState);
            } else {
                debugLog('No saved filter state, using defaults:', filterState);
            }
        }

        // Save filter state to localStorage
        function saveFilterState() {
            try {
                localStorage.setItem('taskraptor_filters', JSON.stringify(filterState));
            } catch (error) {
                console.error('Failed to save filter state:', error);
                if (error.name === 'QuotaExceededError') {
                    showToast('Storage full: Unable to save filter preferences', 'error');
                }
            }
        }

        // Expand state management
        function saveExpandStates() {
            try {
                localStorage.setItem('taskraptor_expand_states', JSON.stringify(expandStates));
            } catch (error) {
                console.error('Failed to save expand states:', error);
                if (error.name === 'QuotaExceededError') {
                    showToast('Storage full: Unable to save task expand states', 'error');
                }
            }
        }

        function loadExpandStates() {
            const saved = localStorage.getItem('taskraptor_expand_states');
            if (saved) {
                expandStates = JSON.parse(saved);
            }
        }

        // Sort state management
        let sortState = {
            columns: {}, // Map of field -> {order: 'none'|'asc'|'desc', priority: 0-4}
            nextPriority: 1
        };

        function initializeSortButtons() {
            const fields = ['modified', 'due_date', 'completed', 'name'];
            fields.forEach(field => {
                sortState.columns[field] = { order: 'none', priority: 0 };
            });
            loadSortState();
        }

        function saveSortState() {
            try {
                localStorage.setItem('taskraptor_sort_state', JSON.stringify(sortState));
            } catch (error) {
                console.error('Failed to save sort state:', error);
                if (error.name === 'QuotaExceededError') {
                    showToast('Storage full: Unable to save sort preferences', 'error');
                }
            }
        }

        function loadSortState() {
            const saved = localStorage.getItem('taskraptor_sort_state');
            if (saved) {
                const loaded = JSON.parse(saved);
                sortState = loaded;
                // Restore button UI from saved state
                Object.keys(sortState.columns).forEach(field => {
                    updateSortButtonUI(field);
                });
            }
        }

        // Helper function to convert number to Unicode subscript
        function toSubscript(num) {
            const subscripts = ['‚ÇÄ', '‚ÇÅ', '‚ÇÇ', '‚ÇÉ', '‚ÇÑ', '‚ÇÖ', '‚ÇÜ', '‚Çá', '‚Çà', '‚Çâ'];
            return String(num).split('').map(digit => subscripts[parseInt(digit)]).join('');
        }

        function handleSortButtonClick(event, field) {
            event.preventDefault();
            event.stopPropagation();
            
            const isMultiSort = event.ctrlKey || event.shiftKey;
            const currentState = sortState.columns[field];
            
            // Cycle through states: none -> asc -> desc -> none
            let newOrder;
            if (currentState.order === 'none') {
                newOrder = 'asc';
            } else if (currentState.order === 'asc') {
                newOrder = 'desc';
            } else {
                newOrder = 'none';
            }
            
            // If not multi-sort, reset all other buttons to neutral
            if (!isMultiSort) {
                Object.keys(sortState.columns).forEach(f => {
                    if (f !== field) {
                        sortState.columns[f] = { order: 'none', priority: 0 };
                        updateSortButtonUI(f);
                    }
                });
                sortState.nextPriority = 1;
            }
            
            // Update this button's state
            if (newOrder === 'none') {
                sortState.columns[field] = { order: 'none', priority: 0 };
            } else {
                // Assign priority if needed
                if (currentState.priority === 0) {
                    sortState.columns[field] = { order: newOrder, priority: sortState.nextPriority };
                    sortState.nextPriority++;
                } else {
                    sortState.columns[field].order = newOrder;
                }
            }
            
            // Renumber priorities if needed (remove gaps)
            if (!isMultiSort || newOrder === 'none') {
                renumberPriorities();
            }
            
            // Update ALL button UIs to ensure priority numbers show/hide correctly
            // when active sort count changes (e.g., adding second sort should show "1" on first button)
            Object.keys(sortState.columns).forEach(f => {
                updateSortButtonUI(f);
            });
            
            saveSortState();
            displayTasks();
            displayFilterBadges();
        }

        function renumberPriorities() {
            // Get all active sorts sorted by current priority
            const activeSorts = Object.entries(sortState.columns)
                .filter(([_, state]) => state.order !== 'none')
                .sort((a, b) => a[1].priority - b[1].priority);
            
            // Renumber them sequentially
            activeSorts.forEach(([field, _], index) => {
                sortState.columns[field].priority = index + 1;
            });
            
            sortState.nextPriority = activeSorts.length + 1;
        }

        function removeSortDimension(field) {
            // Remove this sort dimension
            sortState.columns[field] = { order: 'none', priority: 0 };
            
            // Renumber remaining priorities
            renumberPriorities();
            
            // Update all button UIs
            Object.keys(sortState.columns).forEach(f => {
                updateSortButtonUI(f);
            });
            
            saveSortState();
            displayTasks();
            displayFilterBadges();
        }

        function updateSortButtonUI(field) {
            const button = document.querySelector(`button[data-sort-field="${field}"]`);
            if (!button) return;
            
            const state = sortState.columns[field];
            const indicator = button.querySelector('.sort-indicator');
            const prioritySpan = button.querySelector('.sort-priority');
            
            // Remove all state classes
            button.classList.remove('sort-neutral', 'sort-asc', 'sort-desc');
            
            // Update indicator and class based on order
            if (state.order === 'asc') {
                button.classList.add('sort-asc');
                indicator.textContent = '‚Üë';
            } else if (state.order === 'desc') {
                button.classList.add('sort-desc');
                indicator.textContent = '‚Üì';
            } else {
                button.classList.add('sort-neutral');
                indicator.textContent = '‚áÖ';
            }
            
            // Count active sorts to determine if we should show priority
            const activeSortCount = Object.values(sortState.columns).filter(s => s.order !== 'none').length;
            
            // Update priority display - only show when multiple sorts are active
            if (state.priority > 0 && activeSortCount > 1) {
                prioritySpan.textContent = state.priority;
                prioritySpan.style.display = 'inline';
            } else {
                prioritySpan.style.display = 'none';
            }
        }

        // PAT management
        function savePAT(token) {
            try {
                localStorage.setItem('taskraptor_pat', token);
            } catch (error) {
                console.error('Failed to save PAT:', error);
                if (error.name === 'QuotaExceededError') {
                    showToast('Storage full: Unable to save access token. Clear browser data and try again.', 'error', 8000);
                }
            }
        }

        function loadPAT() {
            return localStorage.getItem('taskraptor_pat');
        }

        function clearPAT() {
            localStorage.removeItem('taskraptor_pat');
        }

        // Workspace management
        function saveWorkspaceId(workspaceId) {
            try {
                debugLog('Saving workspace ID:', workspaceId);
                localStorage.setItem('taskraptor_workspace_id', workspaceId);
                debugLog('Workspace ID saved successfully');
            } catch (error) {
                console.error('Failed to save workspace ID:', error);
                debugLog('‚ùå Failed to save workspace ID:', error.message);
                if (error.name === 'QuotaExceededError') {
                    showToast('Storage full: Unable to save workspace selection', 'error');
                }
            }
        }

        function loadWorkspaceId() {
            const workspaceId = localStorage.getItem('taskraptor_workspace_id');
            debugLog('loadWorkspaceId() returning:', workspaceId);
            return workspaceId;
        }

        function clearWorkspaceId() {
            localStorage.removeItem('taskraptor_workspace_id');
        }

        // Cache management
        function saveCache(data, isFullLoad = false) {
            try {
                // Load existing cache to preserve lastFetchTimes
                const existing = localStorage.getItem('taskraptor_cache');
                const existingData = existing ? JSON.parse(existing) : {};
                const lastFetchTimes = existingData.lastFetchTimes || {};
                
                // Update last fetch time for current filter scope
                const currentScope = filterState.dateRange || 'all';
                lastFetchTimes[currentScope] = Date.now();
                
                // Determine broadest scope:
                // - If this is a full load (no modified_since), we fetched ALL tasks ‚Üí scope is 'all'
                // - If incremental update, keep existing broadestScope
                // - Otherwise use currentScope
                let broadestScope;
                if (isFullLoad) {
                    broadestScope = 'all'; // Full load always fetches everything
                    lastFetchTimes['all'] = Date.now(); // Mark 'all' scope as fetched
                } else if (existingData.broadestScope) {
                    broadestScope = existingData.broadestScope; // Preserve existing
                } else {
                    broadestScope = currentScope; // Fallback
                }
                
                // Create unified cache entry with metadata
                // Cache contains ALL tasks (completed + incomplete)
                const cacheData = {
                    version: APP_VERSION, // Store app version for cache invalidation
                    timestamp: Date.now(),
                    data: data,
                    // Track last fetch time for each filter scope
                    lastFetchTimes: lastFetchTimes,
                    // Store broadest scope fetched (used for scope comparison)
                    broadestScope: broadestScope
                };
                
                localStorage.setItem('taskraptor_cache', JSON.stringify(cacheData));
                debugLog(`üíæ Saved unified cache with ${data.allTasksMap.length} tasks (broadest scope: ${broadestScope}, current filter: ${currentScope})`);
            } catch (error) {
                console.error('Failed to save cache:', error);
                if (error.name === 'QuotaExceededError') {
                    showToast('Storage full: Cache not saved. Tasks will reload on next visit. Consider clearing old browser data.', 'error', 8000);
                    // Optionally clear cache to free space
                    try {
                        localStorage.removeItem('taskraptor_cache');
                    } catch (e) {
                        console.error('Failed to clear cache:', e);
                    }
                }
            }
        }

        function loadCache() {
            const cached = localStorage.getItem('taskraptor_cache');
            if (!cached) return null;
            
            const cacheData = JSON.parse(cached);
            
            // Check app version - invalidate cache if versions don't match
            if (cacheData.version !== APP_VERSION) {
                debugLog(`‚ùå Cache version mismatch (cached: ${cacheData.version || 'unknown'}, current: ${APP_VERSION}) - invalidating cache`);
                localStorage.removeItem('taskraptor_cache');
                return null;
            }
            
            // Check if cache is valid (< 24 hours old)
            const ageHours = (Date.now() - cacheData.timestamp) / (1000 * 60 * 60);
            if (ageHours > 24) {
                debugLog('‚ùå Cache expired (age: ' + ageHours.toFixed(1) + ' hours)');
                return null;
            }
            
            // Check if cached scope encompasses requested scope
            const requestedScope = filterState.dateRange || 'all';
            const cachedBroadestScope = cacheData.broadestScope || 'all';
            
            // Define scope hierarchy (broader > narrower)
            const scopeHierarchy = ['all', 'last90', 'last30', 'last7', 'custom'];
            const cachedScopeIndex = scopeHierarchy.indexOf(cachedBroadestScope);
            const requestedScopeIndex = scopeHierarchy.indexOf(requestedScope);
            
            // Cache is valid if it has broader or equal scope
            if (cachedScopeIndex > requestedScopeIndex) {
                debugLog(`‚ö†Ô∏è Cache scope (${cachedBroadestScope}) is narrower than requested (${requestedScope}) - need fresh data`);
                return null;
            }
            
            debugLog(`üì¶ Loading from cache (cached scope: ${cachedBroadestScope} encompasses requested: ${requestedScope})`);
            return {
                data: cacheData.data,
                timestamp: cacheData.timestamp,
                lastFetchTimes: cacheData.lastFetchTimes || {},
                broadestScope: cachedBroadestScope
            };
        }

        function clearCache(cacheType = null) {
            if (!cacheType) {
                // Clear all caches
                localStorage.removeItem('taskraptor_cache');
                debugLog('üóëÔ∏è Cleared all caches');
            } else {
                // Clear specific cache
                const cached = localStorage.getItem('taskraptor_cache');
                if (cached) {
                    const fullCache = JSON.parse(cached);
                    delete fullCache[cacheType];
                    if (Object.keys(fullCache).length === 0) {
                        localStorage.removeItem('taskraptor_cache');
                    } else {
                        localStorage.setItem('taskraptor_cache', JSON.stringify(fullCache));
                    }
                    debugLog(`üóëÔ∏è Cleared ${cacheType} cache`);
                }
            }
        }
        


        // Toast notifications
        function showToast(message, type = 'info', duration = 5000) {
            const icons = {
                error: '‚ùå',
                success: '‚úÖ',
                info: '‚ÑπÔ∏è',
                warning: '‚ö†Ô∏è'
            };
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span style="font-size: 1.2em;">${icons[type]}</span>
                <span>${message}</span>
                <span class="toast-close">√ó</span>
            `;
            
            // Position toast in stack, accounting for sticky toolbar
            const controls = document.querySelector('.controls');
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            
            // Calculate base top position based on toolbar state
            let baseTop = 20;
            if (controls && scrollTop > 10) {
                // Toolbar is sticky at top
                const toolbarHeight = controls.offsetHeight;
                baseTop = toolbarHeight + 10; // Toolbar height + gap
            }
            
            const existingToasts = document.querySelectorAll('.toast:not(.hiding)');
            let topPosition = baseTop;
            existingToasts.forEach(t => {
                topPosition += t.offsetHeight + 10;
            });
            toast.style.top = topPosition + 'px';
            
            document.body.appendChild(toast);
            
            // Remove toast function
            const removeToast = () => {
                if (!document.body.contains(toast)) return;
                
                toast.classList.add('hiding');
                
                // Wait for animation to complete
                const handleAnimationEnd = () => {
                    if (document.body.contains(toast)) {
                        toast.remove();
                        repositionToasts();
                    }
                };
                
                toast.addEventListener('animationend', handleAnimationEnd, { once: true });
            };
            
            // Auto-hide after duration
            const hideTimeout = setTimeout(removeToast, duration);
            
            // Manual close
            toast.querySelector('.toast-close').onclick = () => {
                clearTimeout(hideTimeout);
                removeToast();
            };
        }
        
        function repositionToasts() {
            const controls = document.querySelector('.controls');
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            
            // Calculate base top position based on toolbar state
            let baseTop = 20;
            if (controls && scrollTop > 10) {
                // Toolbar is sticky at top
                const toolbarHeight = controls.offsetHeight;
                baseTop = toolbarHeight + 10; // Toolbar height + gap
            }
            
            const toasts = document.querySelectorAll('.toast:not(.hiding)');
            let topPosition = baseTop;
            toasts.forEach(toast => {
                toast.style.top = topPosition + 'px';
                topPosition += toast.offsetHeight + 10;
            });
        }

        // Progress tracking
        function updateProgress(current, total, message) {
            const percent = Math.round((current / total) * 100);
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = percent + '%';
            document.getElementById('progressMessage').textContent = message;
        }

        function showProgress() {
            document.getElementById('progressSection').style.display = 'block';
            document.getElementById('content').style.display = 'none';
        }

        function hideProgress() {
            document.getElementById('progressSection').style.display = 'none';
            document.getElementById('content').style.display = 'block';
        }

        function showBackgroundLoadingBanner() {
            // Remove any existing toast
            const existing = document.getElementById('backgroundLoadingToast');
            if (existing) existing.remove();
            
            const toast = document.createElement('div');
            toast.id = 'backgroundLoadingToast';
            toast.className = 'toast';
            
            // Position toast in stack with other toasts
            const existingToasts = document.querySelectorAll('.toast:not(.hiding)');
            let topPosition = 20;
            existingToasts.forEach(t => {
                if (t.id !== 'backgroundLoadingToast') {
                    topPosition += t.offsetHeight + 10;
                }
            });
            
            toast.style.cssText = `
                position: fixed;
                top: ${topPosition}px;
                right: 20px;
                background: white;
                border-left: 4px solid #2c7873;
                padding: 16px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 2000;
                display: flex;
                align-items: center;
                gap: 12px;
                min-width: 300px;
                animation: slideIn 0.3s forwards;
                transition: top 0.3s ease;
            `;
            
            toast.innerHTML = `
                <div class="spinner" style="width: 20px; height: 20px; border: 3px solid #f3f3f3; border-top: 3px solid #2c7873; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <span style="color: #333; font-weight: 500;">Updating tasks in background...</span>
            `;
            
            // Add spinner animation if not already in styles
            if (!document.getElementById('spinnerStyle')) {
                const style = document.createElement('style');
                style.id = 'spinnerStyle';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                    @keyframes slideIn {
                        from { transform: translateX(400px); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(400px); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(toast);
        }

        function showGlobalUpdateSpinners() {
            // Spinners are now always in HTML, just shown via CSS when body has background-loading class
        }

        function hideGlobalUpdateSpinners() {
            // Spinners are now hidden via CSS when body.background-loading class is removed
        }

        function hideBackgroundLoadingBanner() {
            const toast = document.getElementById('backgroundLoadingToast');
            if (toast) {
                toast.classList.add('hiding');
                // Override the inline animation to trigger slideOut
                toast.style.animation = 'slideOut 0.3s ease forwards';
                const handleAnimationEnd = () => {
                    if (document.body.contains(toast)) {
                        toast.remove();
                        repositionToasts();
                    }
                };
                toast.addEventListener('animationend', handleAnimationEnd, { once: true });
            }
            window.backgroundLoadingInProgress = false;
            document.body.classList.remove('background-loading');
            hideGlobalUpdateSpinners();
        }

        // Authentication
        async function authenticate() {
            const token = document.getElementById('patInput').value.trim();
            if (!token) {
                showToast('Please enter your Personal Access Token', 'error');
                return;
            }

            personalAccessToken = token;
            savePAT(token);
            await authenticateAndLoad();
        }

        async function authenticateAndLoad() {
            try {
                debugLog('Authenticating with Asana API...');
                const response = await fetch('https://app.asana.com/api/1.0/users/me', {
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`
                    }
                });

                if (!response.ok) {
                    const statusText = response.statusText || 'Unknown error';
                    debugLog(`Authentication failed: HTTP ${response.status} - ${statusText}`);
                    throw new Error(`Invalid Personal Access Token (HTTP ${response.status}: ${statusText})`);
                }

                const data = await response.json();
                currentUserId = data.data.gid;
                debugLog(`Authenticated as user: ${data.data.name} (${currentUserId})`);

                // Try to load saved workspace ID
                WORKSPACE_ID = loadWorkspaceId();
                
                // If no saved workspace, fetch and let user select
                if (!WORKSPACE_ID) {
                    debugLog('No saved workspace ID, fetching available workspaces...');
                    await selectWorkspace();
                } else {
                    debugLog(`Using saved workspace ID: ${WORKSPACE_ID}`);
                }

                document.getElementById('authSection').style.display = 'none';
                document.getElementById('mainSection').style.display = 'block';

                loadFilterState();
                
                // Try to load from cache first
                const cacheResult = loadCache();
                if (cacheResult) {
                    cachedData = cacheResult.data;
                    const cacheTimestamp = cacheResult.timestamp;
                    showToast('Loading from cache...', 'info', 2000);
                    displayCachedData();
                    // Refresh only modified tasks in background
                    setTimeout(() => refreshData(true, cacheTimestamp), 1000);
                } else {
                    await loadUserTasks();
                }

            } catch (error) {
                showToast('Authentication failed: ' + error.message, 'error');
                clearPAT();
                clearWorkspaceId();
            }
        }

        async function selectWorkspace() {
            try {
                debugLog('Fetching available workspaces...');
                const response = await fetch('https://app.asana.com/api/1.0/workspaces', {
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`
                    }
                });

                if (!response.ok) {
                    const statusText = response.statusText || 'Unknown error';
                    debugLog(`Workspace fetch failed: HTTP ${response.status} - ${statusText}`);
                    throw new Error(`Failed to fetch workspaces (HTTP ${response.status}: ${statusText})`);
                }

                const data = await response.json();
                const workspaces = data.data;
                debugLog(`Found ${workspaces.length} workspace(s):`, workspaces.map(w => w.name));

                if (workspaces.length === 0) {
                    debugLog('No workspaces available for this token');
                    throw new Error('No workspaces found. Your account may not be a member of any Asana workspaces.');
                }

                if (workspaces.length === 1) {
                    // Only one workspace, use it automatically
                    WORKSPACE_ID = workspaces[0].gid;
                    saveWorkspaceId(WORKSPACE_ID);
                    debugLog(`Auto-selected workspace: ${workspaces[0].name} (${WORKSPACE_ID})`);
                    debugLog(`Workspace is_organization: ${workspaces[0].is_organization}`);
                } else {
                    // Multiple workspaces, show selector
                    debugLog('Multiple workspaces available, showing selector...');
                    await showWorkspaceSelector(workspaces);
                }
                
                // Validate workspace access by checking user membership
                await validateWorkspaceAccess();

            } catch (error) {
                throw new Error('Workspace selection failed: ' + error.message);
            }
        }

        async function validateWorkspaceAccess() {
            try {
                debugLog('Validating workspace access...');
                // Try to fetch user's task count in this workspace as a validation
                const testUrl = `https://app.asana.com/api/1.0/tasks?assignee=${currentUserId}&workspace=${WORKSPACE_ID}&limit=1&opt_fields=gid`;
                const response = await fetch(testUrl, {
                    headers: { 'Authorization': `Bearer ${personalAccessToken}` }
                });
                
                if (!response.ok) {
                    const errorText = await response.text().catch(() => '');
                    debugLog(`‚ùå Workspace validation failed: HTTP ${response.status}`, errorText);
                    
                    if (response.status === 400) {
                        throw new Error(`Cannot access workspace. You may not be a member of this workspace, or your Personal Access Token may not have the required permissions.`);
                    } else if (response.status === 403) {
                        throw new Error(`Access denied to workspace. Please check your Personal Access Token has 'tasks:read' permission.`);
                    } else {
                        throw new Error(`Failed to validate workspace access (HTTP ${response.status})`);
                    }
                }
                
                const data = await response.json();
                debugLog('‚úì Workspace access validated successfully');
                debugLog(`  User has access to tasks in workspace ${WORKSPACE_ID}`);
            } catch (error) {
                debugLog('‚ùå Workspace validation error:', error.message);
                clearWorkspaceId();
                throw error;
            }
        }
        
        async function showWorkspaceSelector(workspaces) {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'flex';
                
                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                modalContent.style.maxWidth = '500px';
                
                modalContent.innerHTML = `
                    <h2 style="margin-bottom: 20px;">Select Workspace</h2>
                    <p style="margin-bottom: 20px; color: #666;">Choose which Asana workspace to use with TaskRaptor:</p>
                    <select id="workspaceSelect" style="width: 100%; padding: 10px; margin-bottom: 20px; border: 2px solid #ddd; border-radius: 6px; font-size: 1em;">
                        ${workspaces.map(ws => `<option value="${ws.gid}">${ws.name}</option>`).join('')}
                    </select>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="workspaceConfirm" class="btn" style="padding: 10px 20px; background: #e67e22; color: white; border: none; border-radius: 6px; cursor: pointer;">Continue</button>
                    </div>
                `;
                
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                document.getElementById('workspaceConfirm').onclick = () => {
                    const selectedWorkspaceId = document.getElementById('workspaceSelect').value;
                    WORKSPACE_ID = selectedWorkspaceId;
                    saveWorkspaceId(selectedWorkspaceId);
                    document.body.removeChild(modal);
                    resolve();
                };
            });
        }

        function displayCachedData() {
            allTasksMap = new Map(cachedData.allTasksMap);
            rootItems = cachedData.rootItems;
            allParents = new Set(cachedData.allParents);
            
            // Check for and remove duplicates in cached data
            const uniqueGids = new Set();
            const dedupedRootItems = [];
            rootItems.forEach(task => {
                if (!uniqueGids.has(task.gid)) {
                    uniqueGids.add(task.gid);
                    dedupedRootItems.push(task);
                } else {
                    console.warn(`Removed duplicate from cache: ${task.name} (${task.gid})`);
                }
            });
            
            if (dedupedRootItems.length !== rootItems.length) {
                debugLog(`Cache had ${rootItems.length - dedupedRootItems.length} duplicates, now ${dedupedRootItems.length} unique items`);
                rootItems = dedupedRootItems;
            }
            
            // Mark all items as loading in the background
            window.backgroundLoadingInProgress = true;
            document.body.classList.add('background-loading');
            
            populateParentFilter();
            displayTasks();
            displayFilterBadges();
            
            // Show a subtle banner indicating background refresh
            showBackgroundLoadingBanner();
            
            // Add spinners to all expanded tasks
            showGlobalUpdateSpinners();
        }

        async function refreshData(background = false, cacheTimestamp = null) {
            if (!background) {
                clearCache();
                showProgress();
            }
            await loadUserTasks(background, cacheTimestamp);
        }

        function collapseSingleChildChains() {
            // For each root item, if it only has one child and that child is not a real task,
            // replace the root with the deepest descendant in the single-child chain
            const newRootItems = [];
            
            rootItems.forEach(rootItem => {
                let current = rootItem;
                const chainItems = [current];
                
                // Walk down the chain as long as there's only one child
                while (current.subtasks && current.subtasks.length === 1) {
                    const onlyChild = current.subtasks[0];
                    chainItems.push(onlyChild);
                    current = onlyChild;
                }
                
                // If we walked down a chain (more than 1 item), use the leaf as the root
                if (chainItems.length > 1) {
                    const leaf = chainItems[chainItems.length - 1];
                    // Store just the GIDs and names to avoid circular references
                    leaf.collapsedParentChain = chainItems.slice(0, -1).map(item => ({
                        gid: item.gid,
                        name: item.name
                    }));
                    newRootItems.push(leaf);
                    debugLog(`Collapsed chain: ${chainItems.map(i => i.name).join(' ‚Üí ')}`);
                } else {
                    newRootItems.push(rootItem);
                }
            });
            
            rootItems = newRootItems;
        }

        function collapseSingleChildChainsInArray(tasks) {
            // Helper function to apply collapse logic to any array of tasks
            // (used after filtering to clean up single-child containers)
            const newTasks = [];
            
            tasks.forEach(rootItem => {
                let current = rootItem;
                const chainItems = [current];
                
                // Walk down the chain as long as there's only one child
                while (current.subtasks && current.subtasks.length === 1) {
                    const onlyChild = current.subtasks[0];
                    chainItems.push(onlyChild);
                    current = onlyChild;
                }
                
                // If we walked down a chain (more than 1 item), use the leaf as the root
                if (chainItems.length > 1) {
                    const leaf = chainItems[chainItems.length - 1];
                    
                    // Start with the root item's existing collapsed parent chain
                    const existingChain = rootItem.collapsedParentChain || [];
                    
                    // Add the new chain items (excluding the leaf itself)
                    const newChainPart = chainItems.slice(0, -1).map(item => ({
                        gid: item.gid,
                        name: item.name
                    }));
                    
                    // Combine: existing chain + new collapsed items
                    leaf.collapsedParentChain = [...existingChain, ...newChainPart];
                    newTasks.push(leaf);
                } else {
                    // No collapse needed, just use the item as-is
                    newTasks.push(rootItem);
                }
            });
            
            return newTasks;
        }

        async function createMissingParentItems() {
            const referencedParents = new Set();
            const existingGids = new Set();
            
            // First pass: collect all existing GIDs and referenced parent IDs
            allTasksMap.forEach(task => {
                existingGids.add(task.gid);
                if (task.parent && task.parent.gid) {
                    referencedParents.add(task.parent.gid);
                }
                // Debug: Check for "Unknown Parent" names
                if (task.name && task.name.includes('Unknown')) {
                    debugLog(`Found task with Unknown in name: "${task.name}" (GID: ${task.gid})`);
                }
            });
            
            debugLog(`Found ${existingGids.size} existing tasks and ${referencedParents.size} referenced parents`);
            
            // Fix any tasks that exist with "Unknown Parent" name but have better names in references
            referencedParents.forEach(parentGid => {
                if (existingGids.has(parentGid)) {
                    const parentTask = allTasksMap.get(parentGid);
                    
                    // If the existing task has "Unknown Parent" as its name, try to update it
                    if (parentTask.name === 'Unknown Parent' || !parentTask.name) {
                        // Look for any task that references this parent and use its parent.name
                        allTasksMap.forEach(task => {
                            if (task.parent && task.parent.gid === parentGid && task.parent.name) {
                                debugLog(`Updating "${parentTask.name}" (${parentGid}) to "${task.parent.name}" from reference`);
                                parentTask.name = task.parent.name;
                            }
                        });
                    }
                    
                    // Also try to add project hierarchy if this parent has no parent but its children have memberships
                    if (!parentTask.parent) {
                        debugLog(`Checking children of "${parentTask.name}" (${parentGid}) for membership info...`);
                        allTasksMap.forEach(childTask => {
                            if (childTask.parent && childTask.parent.gid === parentGid) {
                                debugLog(`  Child "${childTask.name}" has memberships:`, childTask.memberships);
                                if (childTask.memberships && childTask.memberships.length > 0) {
                                    const membership = childTask.memberships[0];
                                    debugLog(`    Section GID: ${membership.section?.gid}, Parent GID: ${parentGid}, Match: ${membership.section?.gid === parentGid}`);
                                    debugLog(`    Project: ${membership.project?.name} (${membership.project?.gid})`);
                                    
                                    // If the parent matches a section, link it to the project
                                    if (membership.section && membership.section.gid === parentGid && membership.project) {
                                        parentTask.parent = {
                                            gid: membership.project.gid,
                                            name: membership.project.name
                                        };
                                        parentTask.isSection = true;
                                        debugLog(`‚úì Linked "${parentTask.name}" to project "${membership.project.name}"`);
                                    }
                                }
                            }
                        });
                    }
                }
            });
            
            // Second pass: create placeholder items for missing parents
            const tasksToProcess = Array.from(allTasksMap.values());
            for (const task of tasksToProcess) {
                // If task has a parent that doesn't exist as a task, create it
                if (task.parent && task.parent.gid && !existingGids.has(task.parent.gid)) {
                    debugLog(`Creating missing parent for task "${task.name}": parent GID=${task.parent.gid}, parent name="${task.parent.name}"`);
                    
                    // Check memberships to get proper name and hierarchy
                    if (task.memberships && task.memberships.length > 0) {
                        const membership = task.memberships[0];
                        debugLog(`  Has memberships: section=${membership.section?.gid}, project=${membership.project?.gid}`);
                        
                        // Check if this is a section
                        if (membership.section && membership.section.gid === task.parent.gid) {
                            debugLog(`  Parent IS the section: ${membership.section.name}`);
                            const sectionItem = {
                                gid: membership.section.gid,
                                name: membership.section.name,
                                completed: false,
                                isSection: true,
                                subtasks: [],
                                memberships: [membership]
                            };
                            
                            // Section's parent is the project
                            if (membership.project && membership.project.gid) {
                                sectionItem.parent = {
                                    gid: membership.project.gid,
                                    name: membership.project.name
                                };
                            }
                            
                            allTasksMap.set(sectionItem.gid, sectionItem);
                            existingGids.add(sectionItem.gid);
                            debugLog(`Created section item: ${sectionItem.name}`);
                            
                            // Also create project if needed
                            if (membership.project && !existingGids.has(membership.project.gid)) {
                                const projectItem = {
                                    gid: membership.project.gid,
                                    name: membership.project.name,
                                    completed: false,
                                    isProject: true,
                                    subtasks: [],
                                    parent: null
                                };
                                allTasksMap.set(projectItem.gid, projectItem);
                                existingGids.add(projectItem.gid);
                                debugLog(`Created project item: ${projectItem.name}`);
                            }
                        } else {
                            // Parent exists but is not the section - create as regular parent task placeholder
                            let parentName = task.parent.name;
                            
                            debugLog(`Non-section parent for task "${task.name}": GID=${task.parent.gid}, name="${parentName}"`);
                            
                            // If no parent name, try to fetch from API
                            if (!parentName) {
                                try {
                                    const parentTask = await getTaskDetails(task.parent.gid);
                                    if (parentTask) {
                                        parentName = parentTask.name;
                                    }
                                } catch (error) {
                                    console.warn(`Could not fetch parent details for ${task.parent.gid}:`, error);
                                }
                            }
                            
                            const placeholderItem = {
                                gid: task.parent.gid,
                                name: parentName || 'Unknown Parent (No Access)',
                                completed: false,
                                isPlaceholder: true,
                                subtasks: [],
                                parent: null
                            };
                            allTasksMap.set(placeholderItem.gid, placeholderItem);
                            existingGids.add(placeholderItem.gid);
                        }
                    } else {
                        // No memberships data or parent not in memberships
                        // Try to fetch parent details from API if name is missing
                        let parentName = task.parent.name;
                        
                        if (!parentName) {
                            try {
                                const parentTask = await getTaskDetails(task.parent.gid);
                                if (parentTask) {
                                    parentName = parentTask.name;
                                }
                            } catch (error) {
                                console.warn(`Could not fetch parent details for ${task.parent.gid}:`, error);
                            }
                        }
                        
                        const placeholderItem = {
                            gid: task.parent.gid,
                            name: parentName || 'Unknown Parent (No Access)',
                            completed: false,
                            isPlaceholder: true,
                            subtasks: [],
                            parent: null
                        };
                        allTasksMap.set(placeholderItem.gid, placeholderItem);
                        existingGids.add(placeholderItem.gid);
                        debugLog(`Created placeholder item: ${placeholderItem.name} (GID: ${placeholderItem.gid})`);
                    }
                } else if (!task.parent && task.memberships && task.memberships.length > 0) {
                    // Task has no parent but has memberships - create project/section hierarchy
                    const membership = task.memberships[0];
                    
                    // Create project if needed
                    if (membership.project && !existingGids.has(membership.project.gid)) {
                        const projectItem = {
                            gid: membership.project.gid,
                            name: membership.project.name,
                            completed: false,
                            isProject: true,
                            subtasks: [],
                            parent: null
                        };
                        allTasksMap.set(projectItem.gid, projectItem);
                        existingGids.add(projectItem.gid);
                        debugLog(`Created project item: ${projectItem.name}`);
                    }
                    
                    // Create section if needed
                    if (membership.section && !existingGids.has(membership.section.gid)) {
                        const sectionItem = {
                            gid: membership.section.gid,
                            name: membership.section.name,
                            completed: false,
                            isSection: true,
                            subtasks: [],
                            parent: membership.project ? {
                                gid: membership.project.gid,
                                name: membership.project.name
                            } : null
                        };
                        allTasksMap.set(sectionItem.gid, sectionItem);
                        existingGids.add(sectionItem.gid);
                        debugLog(`Created section item: ${sectionItem.name}`);
                    }
                    
                    // Link task to section or project
                    if (membership.section) {
                        task.parent = {
                            gid: membership.section.gid,
                            name: membership.section.name
                        };
                        debugLog(`Linked task "${task.name}" to section "${membership.section.name}"`);
                    } else if (membership.project) {
                        task.parent = {
                            gid: membership.project.gid,
                            name: membership.project.name
                        };
                        debugLog(`Linked task "${task.name}" to project "${membership.project.name}"`);
                    }
                }
            }
            
            debugLog(`After creating missing parents: ${allTasksMap.size} total items`);
        }

        // Fetch all tasks with pagination
        async function loadUserTasks(background = false, cacheTimestamp = null) {
            debugLog('üöÄ loadUserTasks STARTING - App version:', APP_VERSION);
            debugLog('Background mode:', background, '| Cache timestamp:', cacheTimestamp ? new Date(cacheTimestamp).toISOString() : 'none');
            try {
                // Validate that we have a workspace ID before proceeding
                if (!WORKSPACE_ID) {
                    debugLog('‚ùå ERROR: WORKSPACE_ID is not set');
                    throw new Error('Workspace ID is not set. Please log out and log in again to select a workspace.');
                }
                
                debugLog('Using workspace ID:', WORKSPACE_ID);
                
                if (!background) showProgress();
                
                let currentProgress = 0;
                const setProgress = (progress, message) => {
                    currentProgress = progress;
                    updateProgress(currentProgress, 100, message);
                };

                setProgress(0, 'Fetching your tasks...');

                // Build API URL with filters
                // Include memberships to get project/section hierarchy
                // Add explicit limit parameter for large result sets
                let apiUrl = `https://app.asana.com/api/1.0/tasks?assignee=${currentUserId}&workspace=${WORKSPACE_ID}&limit=100&opt_fields=name,completed,completed_at,assignee,due_on,modified_at,parent,parent.name,notes,html_notes,memberships,memberships.project,memberships.project.name,memberships.section,memberships.section.name`;
                
                // For incremental updates, only fetch tasks modified since last fetch for this scope
                // Skip completion filters to catch ALL status changes (incomplete‚Üícomplete, complete‚Üíincomplete)
                if (background && cacheTimestamp) {
                    const modifiedSince = new Date(cacheTimestamp).toISOString();
                    apiUrl += `&modified_since=${modifiedSince}`;
                    debugLog('‚ú® Incremental update: fetching tasks modified since', modifiedSince);
                } else {
                    // For initial loads, NEVER apply date filtering at API level
                    // This ensures cache contains ALL tasks, allowing filter changes without API calls
                    // when switching from broader to narrower scopes (e.g., 'all' ‚Üí 'last30')
                    debugLog('üìÖ Initial load: fetching ALL tasks (no date filtering at API level)');
                }

                const allTasks = [];
                let offset = null;
                let pageCount = 0;
                let useMinimalParams = false; // Flag to track if we should use minimal parameters

                do {
                    let url = offset ? `${apiUrl}&offset=${offset}` : apiUrl;
                    debugLog('Fetching:', url.substring(0, 150) + '...');
                    
                    let response = await fetch(url, {
                        headers: { 'Authorization': `Bearer ${personalAccessToken}` }
                    });

                    // If we get a 400 error and haven't tried minimal params yet, retry with minimal params
                    if (!response.ok && response.status === 400 && !useMinimalParams) {
                        debugLog('‚ö†Ô∏è Got 400 error with full parameters, retrying with minimal parameters...');
                        
                        // Build minimal URL with just assignee, workspace, and explicit limit
                        const minimalBaseUrl = `https://app.asana.com/api/1.0/tasks?assignee=${currentUserId}&workspace=${WORKSPACE_ID}&limit=100`;
                        
                        // Add modified_since if this is a background update
                        let minimalApiUrl = minimalBaseUrl;
                        if (background && cacheTimestamp) {
                            const modifiedSince = new Date(cacheTimestamp).toISOString();
                            minimalApiUrl += `&modified_since=${modifiedSince}`;
                        }
                        
                        // Rebuild URL with minimal params
                        url = offset ? `${minimalApiUrl}&offset=${offset}` : minimalApiUrl;
                        debugLog('Retry URL:', url.substring(0, 150) + '...');
                        
                        // Retry the request
                        response = await fetch(url, {
                            headers: { 'Authorization': `Bearer ${personalAccessToken}` }
                        });
                        
                        if (response.ok) {
                            debugLog('‚úì Minimal parameters worked! Continuing with minimal params.');
                            useMinimalParams = true;
                            // Update apiUrl for subsequent pages
                            apiUrl = minimalApiUrl;
                        }
                    }

                    if (!response.ok) {
                        const errorText = await response.text().catch(() => 'Unable to read error response');
                        debugLog('‚ùå API Error:', response.status, response.statusText);
                        debugLog('Error response body:', errorText);
                        debugLog('Request URL:', url);
                        debugLog('User ID:', currentUserId);
                        debugLog('Workspace ID:', WORKSPACE_ID);
                        
                        let errorMessage = `Failed to fetch tasks (HTTP ${response.status}): ${response.statusText}.`;
                        
                        if (response.status === 400) {
                            errorMessage += ' This usually means invalid parameters or you are not a member of the selected workspace.';
                        } else if (response.status === 403) {
                            errorMessage += ' Access denied. Check your Personal Access Token permissions.';
                        } else if (response.status === 401) {
                            errorMessage += ' Authentication failed. Your Personal Access Token may be invalid or expired.';
                        }
                        
                        errorMessage += ' Check console for details.';
                        throw new Error(errorMessage);
                    }

                    const data = await response.json();
                    allTasks.push(...data.data);
                    
                    pageCount++;
                    const fetchProgress = Math.min(30, (allTasks.length / 200) * 30);
                    setProgress(fetchProgress, `Fetched ${allTasks.length} tasks (page ${pageCount})...`);

                    offset = data.next_page ? data.next_page.offset : null;
                } while (offset);
                
                // If we had to use minimal parameters, warn the user
                if (useMinimalParams) {
                    showToast('‚ö†Ô∏è Using minimal API parameters due to compatibility issue. Some task details may be missing.', 'warning', 5000);
                    debugLog('‚ö†Ô∏è Fetched with minimal parameters - tasks may be missing some fields (notes, memberships, etc.)');
                }

                setProgress(35, `Processing ${allTasks.length} tasks...`);

                // Analyze what was fetched
                const tasksWithParent = allTasks.filter(t => t.parent).length;
                const tasksWithoutParent = allTasks.filter(t => !t.parent).length;
                const completedCount = allTasks.filter(t => t.completed).length;
                const incompleteCount = allTasks.filter(t => !t.completed).length;
                debugLog(`üìä API returned ${allTasks.length} tasks:`);
                debugLog(`   - ${tasksWithoutParent} top-level tasks (no parent)`);
                debugLog(`   - ${tasksWithParent} subtasks (have parent)`);
                debugLog(`   - ${completedCount} completed, ${incompleteCount} incomplete`);
                debugLog(`   - Sample of first 10:`, allTasks.slice(0, 10).map(t => ({
                    name: t.name,
                    completed: t.completed,
                    hasParent: !!t.parent,
                    parentName: t.parent?.name
                })));

                // Do NOT filter by completion status here!
                // The cache should contain ALL tasks (completed + incomplete)
                // Both completion AND date filtering happen client-side in displayTasks()
                // This allows instant switching between ALL filter types without API calls
                debugLog(`Keeping all ${allTasks.length} tasks in cache (${completedCount} completed, ${incompleteCount} incomplete)`);
                debugLog('All filtering (completion, date, parent) will be applied client-side when displaying tasks');

                // Initialize task structure (NO FILTERING - all tasks go into cache)
                const tasksToCache = allTasks.map(task => {
                    // Ensure task has required structure
                    if (!task.subtasks) task.subtasks = [];
                    if (task.comments === undefined) task.comments = null;
                    task.subtasksLoaded = false; // Mark as not loaded yet
                    
                    // If using minimal params, some fields may be missing - set defaults
                    if (useMinimalParams) {
                        if (!task.notes) task.notes = '';
                        if (!task.html_notes) task.html_notes = '';
                        if (!task.memberships) task.memberships = [];
                        if (!task.modified_at) task.modified_at = new Date().toISOString();
                    }
                    
                    return task;
                });
                debugLog(`Prepared ${tasksToCache.length} unfiltered tasks for caching`);
                debugLog('Sample tasks:', tasksToCache.slice(0, 3).map(t => ({name: t.name, completed: t.completed, hasParent: !!t.parent})));

                // If background loading, preserve existing tasks and merge new data
                // Otherwise, clear and rebuild
                if (!background) {
                    allTasksMap.clear();
                    tasksToCache.forEach(task => allTasksMap.set(task.gid, task));
                } else {
                    // During background loading, UPDATE existing tasks instead of replacing them
                    let updatedCount = 0;
                    let newCount = 0;
                    tasksToCache.forEach(task => {
                        const existingTask = allTasksMap.get(task.gid);
                        if (existingTask) {
                            // Update only the core task properties, preserve UI state and loaded data
                            existingTask.name = task.name;
                            existingTask.completed = task.completed;
                            existingTask.assignee = task.assignee;
                            existingTask.due_on = task.due_on;
                            existingTask.modified_at = task.modified_at;
                            existingTask.parent = task.parent;
                            existingTask.notes = task.notes;
                            existingTask.html_notes = task.html_notes;
                            existingTask.memberships = task.memberships;
                            // Keep existing: comments, notesExpanded, commentsShown, subtasks, subtasksLoaded
                            updatedCount++;
                        } else {
                            // New task, add it
                            allTasksMap.set(task.gid, task);
                            newCount++;
                        }
                    });
                    debugLog(`üì• Merged: ${updatedCount} updated, ${newCount} new tasks. Total in cache: ${allTasksMap.size}`);
                }

                // Create placeholder items for missing parents (projects/sections)
                await createMissingParentItems();

                // Load subtasks for all fetched tasks
                // In incremental mode (background with cacheTimestamp), only load subtasks for new/modified tasks
                setProgress(40, 'Loading subtasks...');
                const tasksNeedingSubtasks = background && cacheTimestamp 
                    ? tasksToCache.filter(t => {
                        const existing = allTasksMap.get(t.gid);
                        return !existing || !existing.subtasksLoaded;
                    })
                    : tasksToCache;
                
                debugLog(`Loading subtasks for ${tasksNeedingSubtasks.length} tasks (${tasksToCache.length - tasksNeedingSubtasks.length} already cached)`);
                
                for (let i = 0; i < tasksNeedingSubtasks.length; i++) {
                    tasksBeingLoaded.add(tasksNeedingSubtasks[i].gid); // Mark as loading
                    const isAssignedToUser = true; // all tasks are assigned to user
                    await loadSubtasksFiltered(tasksNeedingSubtasks[i].gid, isAssignedToUser);
                    tasksBeingLoaded.delete(tasksNeedingSubtasks[i].gid); // Mark as loaded
                    if (i % 5 === 0 || i === tasksNeedingSubtasks.length - 1) {
                        const subtaskProgress = 40 + ((i / Math.max(tasksNeedingSubtasks.length, 1)) * 30);
                        setProgress(subtaskProgress, `Loading subtasks: ${i + 1}/${tasksNeedingSubtasks.length}`);
                    }
                }

                // NOW build hierarchy - allTasksMap contains all tasks and their subtasks
                setProgress(70, 'Building task hierarchy...');
                
                // First, build parent-child relationships for projects/sections
                // Clear any existing subtasks arrays for projects/sections
                allTasksMap.forEach(task => {
                    if (task.isProject || task.isSection) {
                        task.subtasks = [];
                    }
                });
                
                // Build the subtasks arrays based on parent relationships
                allTasksMap.forEach(task => {
                    if (task.parent && task.parent.gid) {
                        const parent = allTasksMap.get(task.parent.gid);
                        if (parent) {
                            if (!parent.subtasks) {
                                parent.subtasks = [];
                            }
                            // Only add if not already present
                            if (!parent.subtasks.some(st => st.gid === task.gid)) {
                                parent.subtasks.push(task);
                            }
                        }
                    }
                });
                
                rootItems = [];
                allParents.clear();
                const rootGids = new Set(); // Track which GIDs we've added as roots
                const trueRootMap = new Map(); // Maps task GID to its true root GID

                // Iterate through ALL tasks in allTasksMap to find their true roots
                const allTasksArray = Array.from(allTasksMap.values());
                debugLog(`Building hierarchy from ${allTasksArray.length} total tasks (including subtasks)`);
                
                for (let i = 0; i < allTasksArray.length; i++) {
                    const task = allTasksArray[i];
                    
                    // Find the TRUE root by walking up the parent chain
                    const parentChain = await getParentChain(task.gid);
                    const trueRoot = parentChain.length > 0 ? parentChain[0] : task;
                    
                    // Store mapping from this task to its true root
                    trueRootMap.set(task.gid, trueRoot.gid);
                    
                    if (i < 5) {
                        debugLog(`Task ${i}: "${task.name}" (GID: ${task.gid})`);
                        debugLog(`  Has parent: ${task.parent ? 'yes (' + task.parent.gid + ')' : 'no'}`);
                        debugLog(`  Parent object:`, task.parent);
                        debugLog(`  Parent chain length: ${parentChain.length}`);
                        if (parentChain.length > 0) {
                            debugLog(`  Parent chain:`, parentChain.map(p => p.name).join(' ‚Üí '));
                        }
                        debugLog(`  True root: "${trueRoot.name}" (${trueRoot.gid})`);
                        debugLog(`  Subtasks: ${task.subtasks ? task.subtasks.length : 0}`);
                    }
                    
                    // Add true root to rootItems if not already added
                    if (!rootGids.has(trueRoot.gid)) {
                        rootItems.push(trueRoot);
                        rootGids.add(trueRoot.gid);
                        
                        if (rootItems.length <= 5) {
                            debugLog(`‚úì Added root #${rootItems.length}: "${trueRoot.name}" (${trueRoot.gid})`);
                        }
                        
                        // Add to parent filter options
                        allParents.add(JSON.stringify({
                            gid: trueRoot.gid,
                            name: trueRoot.name
                        }));
                    }
                    
                    if (i % 10 === 0) {
                        const hierarchyProgress = 70 + ((i / allTasksArray.length) * 20);
                        setProgress(hierarchyProgress, `Building hierarchy: ${i + 1}/${allTasksArray.length}`);
                    }
                }
                
                debugLog(`Total root items found: ${rootItems.length}`);
                debugLog(`rootGids size: ${rootGids.size}`);
                debugLog(`allTasksMap size: ${allTasksMap.size}`);
                
                // Check for duplicates
                const uniqueGids = new Set(rootItems.map(t => t.gid));
                if (uniqueGids.size !== rootItems.length) {
                    console.warn(`‚ö†Ô∏è Found ${rootItems.length - uniqueGids.size} duplicate root items!`);
                    // Remove duplicates
                    const seen = new Set();
                    rootItems = rootItems.filter(task => {
                        if (seen.has(task.gid)) {
                            debugLog(`  Removing duplicate: ${task.name} (${task.gid})`);
                            return false;
                        }
                        seen.add(task.gid);
                        return true;
                    });
                    debugLog(`After deduplication: ${rootItems.length} root items`);
                }
                
                // Fetch missing ancestors for each root item
                setProgress(91, 'Checking for missing ancestors...');
                debugLog(`Checking ${rootItems.length} root items for missing ancestors...`);
                
                for (let i = 0; i < rootItems.length; i++) {
                    const root = rootItems[i];
                    
                    // Debug: Log each root's parent status
                    debugLog(`Root #${i + 1}: "${root.name}" (${root.gid})`);
                    debugLog(`  Has parent field: ${root.parent ? 'yes' : 'no'}`);
                    
                    // If root has no parent field at all, try fetching it directly to see if Asana has parent info
                    if (!root.parent && !root.isProject && !root.isSection) {
                        debugLog(`  Root has no parent field, fetching directly from API...`);
                        try {
                            const fetchedRoot = await fetch(`https://app.asana.com/api/1.0/tasks/${root.gid}?opt_fields=parent,parent.name,memberships,memberships.project,memberships.project.name,memberships.section,memberships.section.name`, {
                                headers: { 'Authorization': `Bearer ${personalAccessToken}` }
                            });
                            
                            if (fetchedRoot.ok) {
                                const data = await fetchedRoot.json();
                                if (data.data.parent) {
                                    debugLog(`  ‚úì Found parent via API: "${data.data.parent.name}" (${data.data.parent.gid})`);
                                    root.parent = data.data.parent;
                                } else {
                                    debugLog(`  No parent field, checking memberships...`);
                                    // Update root's memberships if we got them
                                    if (data.data.memberships) {
                                        root.memberships = data.data.memberships;
                                        debugLog(`  Updated memberships:`, data.data.memberships);
                                        
                                        // If task belongs to a section, create parent link to that section
                                        if (data.data.memberships.length > 0 && data.data.memberships[0].section) {
                                            const section = data.data.memberships[0].section;
                                            debugLog(`  ‚úì Task belongs to section: "${section.name}" (${section.gid})`);
                                            
                                            // Check if section exists in map, if not create it
                                            if (!allTasksMap.has(section.gid)) {
                                                const project = data.data.memberships[0].project;
                                                const sectionItem = {
                                                    gid: section.gid,
                                                    name: section.name,
                                                    completed: false,
                                                    isSection: true,
                                                    subtasks: [],
                                                    parent: project ? {gid: project.gid, name: project.name} : null
                                                };
                                                allTasksMap.set(section.gid, sectionItem);
                                                debugLog(`  Created section placeholder: "${section.name}"`);
                                                
                                                // Create project if needed
                                                if (project && !allTasksMap.has(project.gid)) {
                                                    const projectItem = {
                                                        gid: project.gid,
                                                        name: project.name,
                                                        completed: false,
                                                        isProject: true,
                                                        subtasks: [],
                                                        parent: null
                                                    };
                                                    allTasksMap.set(project.gid, projectItem);
                                                    debugLog(`  Created project placeholder: "${project.name}"`);
                                                }
                                            }
                                            
                                            // Link root to section
                                            root.parent = {gid: section.gid, name: section.name};
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            console.warn(`  Could not fetch root details:`, error);
                        }
                    }
                    
                    if (root.parent) {
                        debugLog(`  Parent: "${root.parent.name}" (${root.parent.gid})`);
                        debugLog(`  Parent exists in map: ${allTasksMap.has(root.parent.gid)}`);
                    }
                    
                    // Check if this root has a parent that's not in the map
                    if (root.parent && root.parent.gid && !allTasksMap.has(root.parent.gid)) {
                        debugLog(`Root "${root.name}" has missing parent: ${root.parent.name} (${root.parent.gid})`);
                        
                        // Fetch the entire ancestor chain
                        await fetchMissingAncestors(root.parent.gid);
                        
                        // After fetching, find the new true root
                        const parentChain = await getParentChain(root.gid);
                        const newRoot = parentChain.length > 0 ? parentChain[0] : root;
                        
                        if (newRoot.gid !== root.gid) {
                            debugLog(`  Replacing root "${root.name}" with "${newRoot.name}"`);
                            rootItems[i] = newRoot;
                            rootGids.delete(root.gid);
                            rootGids.add(newRoot.gid);
                            
                            // Update parent filter options
                            allParents.add(JSON.stringify({
                                gid: newRoot.gid,
                                name: newRoot.name
                            }));
                        }
                    }
                    
                    if ((i + 1) % 3 === 0 || i === rootItems.length - 1) {
                        const ancestorProgress = 91 + ((i + 1) / rootItems.length) * 3;
                        setProgress(ancestorProgress, `Checking ancestors: ${i + 1}/${rootItems.length}`);
                    }
                }
                
                // Remove any duplicate roots that may have been created
                const finalUniqueGids = new Set();
                rootItems = rootItems.filter(root => {
                    if (finalUniqueGids.has(root.gid)) {
                        return false;
                    }
                    finalUniqueGids.add(root.gid);
                    return true;
                });
                
                debugLog(`After ancestor fetch: ${rootItems.length} root items`);
                
                // Collapse single-child chains into breadcrumbs
                collapseSingleChildChains();
                debugLog(`After collapsing single-child chains: ${rootItems.length} root items`);
                
                setProgress(90, 'Finalizing...');

                // Save to cache
                // Pass isFullLoad=true for initial loads (not background updates)
                // This ensures broadestScope is set to 'all' since we fetched all tasks
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                }, !background); // isFullLoad = true when NOT a background update

                populateParentFilter();
                
                // Only re-render if NOT background loading
                // During background load, we skip displayTasks() to avoid destroying expanded tasks
                if (!background) {
                    displayTasks();
                }
                
                displayFilterBadges();
                
                setProgress(100, 'Complete!');
                
                // Store refresh timestamp
                window.lastRefreshTime = new Date();
                
                // Show appropriate success message and log summary
                if (background && cacheTimestamp) {
                    const unchangedCount = allTasksMap.size - tasksToCache.length;
                    debugLog(`üéØ Incremental update complete:`);
                    debugLog(`   - ${tasksToCache.length} tasks fetched from API (modified since cache)`);
                    debugLog(`   - ${unchangedCount} tasks used from cache (unchanged)`);
                    debugLog(`   - ${allTasksMap.size} total tasks available`);
                    debugLog(`   - Performance: Saved ${unchangedCount} task fetches + subtask API calls!`);
                    
                    if (tasksToCache.length === 0) {
                        showToast(`‚ú® No tasks modified since last refresh. Cache is up to date.`, 'success', 3000);
                    } else if (tasksToCache.length === 1) {
                        showToast(`‚ú® 1 task modified since last refresh. Cache updated.`, 'success', 3000);
                    } else {
                        showToast(`‚ú® ${tasksToCache.length} tasks modified since last refresh. Cache updated.`, 'success', 3000);
                    }
                } else {
                    showToast(`Loaded ${tasksToCache.length} tasks successfully`, 'success', 2000);
                }
                
                if (!background) {
                    hideProgress();
                } else {
                    hideBackgroundLoadingBanner();
                }

            } catch (error) {
                console.error(error);
                showToast('Error loading tasks: ' + error.message, 'error');
                if (!background) {
                    hideProgress();
                } else {
                    hideBackgroundLoadingBanner();
                }
            } finally {
                // Ensure background loading flag is always cleared
                if (background && window.backgroundLoadingInProgress) {
                    window.backgroundLoadingInProgress = false;
                    document.body.classList.remove('background-loading');
                    hideGlobalUpdateSpinners();
                    
                    // Now that background loading is complete, refresh the display
                    displayTasks();
                }
            }
        }

        function getDateFilter() {
            const now = new Date();
            let filterDate = null;

            switch (filterState.dateRange) {
                case 'last7':
                    filterDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    break;
                case 'last30':
                    filterDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                    break;
                case 'last90':
                    filterDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                    break;
                case 'custom':
                    if (filterState.customStart) {
                        filterDate = new Date(filterState.customStart);
                    }
                    break;
                case 'all':
                    return null;
            }

            return filterDate ? filterDate.toISOString() : null;
        }

        function filterTasksByDate(tasks) {
            // ALL date filtering is now done client-side
            // This allows switching between date ranges without API calls
            
            if (filterState.dateRange === 'all') {
                debugLog(`üìÖ Date filter: 'all' - showing all ${tasks.length} tasks`);
                return tasks;
            }

            const dateFilter = getDateFilter();
            if (!dateFilter) {
                debugLog(`üìÖ Date filter: no filter date calculated - showing all ${tasks.length} tasks`);
                return tasks;
            }

            const filterTime = new Date(dateFilter).getTime();
            debugLog(`üìÖ Date filter: ${filterState.dateRange} (cutoff: ${new Date(filterTime).toLocaleDateString()})`);

            let totalTasksChecked = 0;
            let tasksMatched = 0;

            // Helper function to check if a single task matches the date filter
            function taskMatchesDate(task) {
                totalTasksChecked++;
                
                // Projects and sections always pass (they're containers)
                if (task.isProject || task.isSection || task.isPlaceholder) {
                    return true;
                }
                
                // For completed tasks, use completed_at (when they were marked complete)
                // For incomplete tasks, use modified_at (when they were last changed)
                
                if (task.completed) {
                    // Filter completed tasks by completion date
                    if (!task.completed_at) {
                        // If no completed_at, fall back to modified_at
                        if (!task.modified_at) {
                            tasksMatched++;
                            return true; // Keep if no date info
                        }
                        const modifiedTime = new Date(task.modified_at).getTime();
                        const matches = modifiedTime >= filterTime;
                        if (matches) tasksMatched++;
                        return matches;
                    }
                    const completedTime = new Date(task.completed_at).getTime();
                    const matches = completedTime >= filterTime;
                    if (matches) tasksMatched++;
                    return matches;
                } else {
                    // For incomplete tasks, use modified_at
                    // Only filter if showing 'both' or 'completed' mode
                    // In 'incomplete' mode, show ALL incomplete tasks regardless of date
                    if (filterState.completion === 'uncompleted') {
                        tasksMatched++;
                        return true; // Show all incomplete tasks
                    }
                    
                    if (!task.modified_at) {
                        tasksMatched++;
                        return true; // Keep if no date info
                    }
                    const modifiedTime = new Date(task.modified_at).getTime();
                    const matches = modifiedTime >= filterTime;
                    if (matches) tasksMatched++;
                    return matches;
                }
            }

            // Recursive function to filter a task and its subtasks
            function filterTaskRecursive(task) {
                // Check if this task matches the date filter
                const taskMatches = taskMatchesDate(task);
                
                // Filter subtasks recursively
                let filteredSubtasks = [];
                if (task.subtasks && task.subtasks.length > 0) {
                    filteredSubtasks = task.subtasks
                        .map(st => filterTaskRecursive(st))
                        .filter(st => st !== null);
                }
                
                // Keep this task if:
                // 1. It matches the date filter, OR
                // 2. It has subtasks that match (ancestor of matching task)
                if (taskMatches || filteredSubtasks.length > 0) {
                    // Clone the task to avoid mutating the original
                    return {
                        ...task,
                        subtasks: filteredSubtasks
                    };
                }
                
                // This task and all its subtasks are filtered out
                return null;
            }

            // Apply recursive filtering to all root items
            const filteredTasks = tasks
                .map(task => filterTaskRecursive(task))
                .filter(task => task !== null);
            
            debugLog(`üìÖ Date filter result: ${filteredTasks.length} root items kept (from ${tasks.length} total)`);
            debugLog(`   - Checked ${totalTasksChecked} tasks, ${tasksMatched} matched the date criteria`);
            if (tasksMatched < totalTasksChecked) {
                debugLog(`   - Filtered out ${totalTasksChecked - tasksMatched} tasks outside date range`);
            }
            
            return filteredTasks;
        }

        function populateParentFilter() {
            const select = document.getElementById('parentFilter');
            select.innerHTML = '<option value="">All Projects</option>';
            
            const parentArray = Array.from(allParents).map(p => JSON.parse(p));
            parentArray.sort((a, b) => a.name.localeCompare(b.name));
            
            parentArray.forEach(parent => {
                const option = document.createElement('option');
                option.value = parent.gid;
                option.textContent = parent.name;
                if (parent.gid === filterState.parentFilter) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        async function fetchMissingAncestors(parentGid) {
            // Fetch all missing ancestors starting from a parent GID (parent, grandparent, etc.)
            if (!parentGid) return;
            
            let currentParentGid = parentGid;
            
            while (currentParentGid) {
                // Check if parent already exists AND has parent info
                if (allTasksMap.has(currentParentGid)) {
                    const parent = allTasksMap.get(currentParentGid);
                    
                    // If parent exists but parent.parent is undefined (not null, but undefined),
                    // it means parent info wasn't fetched. Re-fetch it.
                    if (parent.parent === undefined) {
                        debugLog(`Parent "${parent.name}" exists but lacks parent info, re-fetching...`);
                        try {
                            const refreshedTask = await fetch(`https://app.asana.com/api/1.0/tasks/${currentParentGid}?opt_fields=name,completed,completed_at,assignee,due_on,modified_at,parent,parent.name,notes,html_notes`, {
                                headers: { 'Authorization': `Bearer ${personalAccessToken}` }
                            });
                            
                            if (refreshedTask.ok) {
                                const data = await refreshedTask.json();
                                const taskData = data.data;
                                // Update the parent field while preserving other data
                                parent.parent = taskData.parent;
                                debugLog(`Updated parent info for "${parent.name}": ${parent.parent ? parent.parent.name : 'no parent (root)'}`);
                            }
                        } catch (error) {
                            console.warn(`Could not refresh parent info for ${currentParentGid}:`, error);
                        }
                    }
                    
                    // Now continue up the chain
                    currentParentGid = parent.parent ? parent.parent.gid : null;
                    continue;
                }
                
                // Parent doesn't exist, fetch it
                try {
                    const parentTask = await getTaskDetails(currentParentGid);
                    if (parentTask) {
                        // Initialize required fields
                        parentTask.subtasks = parentTask.subtasks || [];
                        parentTask.comments = null;
                        parentTask.subtasksLoaded = false;
                        
                        allTasksMap.set(parentTask.gid, parentTask);
                        debugLog(`Fetched missing ancestor: "${parentTask.name}" (${parentTask.gid})`);
                        
                        // Continue up the chain
                        currentParentGid = parentTask.parent ? parentTask.parent.gid : null;
                    } else {
                        break;
                    }
                } catch (error) {
                    console.warn(`Could not fetch ancestor ${currentParentGid}:`, error);
                    break;
                }
            }
        }

        async function getParentChain(taskGid) {
            const chain = [];
            let currentTask = allTasksMap.get(taskGid);
            
            if (!currentTask) {
                // Try fetching from API if not in map
                currentTask = await getTaskDetails(taskGid);
            }
            
            if (!currentTask) return chain;
            
            // Build chain from parent relationships
            // Parent items should already exist in allTasksMap thanks to createMissingParentItems()
            while (currentTask && currentTask.parent) {
                // Look up parent in map first (don't fetch projects/sections from API)
                const parent = allTasksMap.get(currentTask.parent.gid);
                if (!parent) break;
                chain.unshift(parent);
                currentTask = parent;
            }
            
            return chain;
        }

        async function getTaskDetails(taskGid) {
            // Return from cache if already fetched
            if (allTasksMap.has(taskGid)) {
                return allTasksMap.get(taskGid);
            }

            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}?opt_fields=name,completed,completed_at,assignee,due_on,modified_at,parent,parent.name,notes,html_notes`, {
                    headers: { 'Authorization': `Bearer ${personalAccessToken}` }
                });

                if (!response.ok) return null;

                const data = await response.json();
                const task = data.data;
                
                // Preserve existing comments and UI state if task already exists
                const existingTask = allTasksMap.get(task.gid);
                if (existingTask) {
                    task.comments = existingTask.comments;
                    task.notesExpanded = existingTask.notesExpanded;
                    task.commentsShown = existingTask.commentsShown;
                    task.subtasks = existingTask.subtasks || [];
                } else {
                    task.subtasks = [];
                    task.comments = null;
                }
                
                allTasksMap.set(task.gid, task);
                return task;
            } catch (error) {
                console.error('Error fetching task:', error);
                return null;
            }
        }

        async function loadSubtasksFiltered(taskGid, parentAssignedToUser) {
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            // Skip if this is a project or section (not a real task)
            if (task.isProject || task.isSection || task.isPlaceholder) {
                task.subtasksLoaded = true; // Mark as loaded so we don't try again
                return;
            }
            
            // If subtasks already loaded, skip
            if (task.subtasksLoaded) {
                return;
            }

            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}/subtasks?opt_fields=name,completed,completed_at,assignee,due_on,modified_at,parent,parent.name,notes,html_notes,memberships,memberships.project,memberships.project.name,memberships.section,memberships.section.name`, {
                    headers: { 'Authorization': `Bearer ${personalAccessToken}` }
                });

                if (!response.ok) return;

                const data = await response.json();
                task.subtasks = [];
                task.subtasksLoaded = true; // Mark as loaded

                for (const subtask of data.data) {
                    const isAssignedToUser = subtask.assignee && subtask.assignee.gid === currentUserId;
                    const isUnassigned = !subtask.assignee;
                    
                    // Check if subtask matches the completion filter
                    const matchesCompletionFilter = 
                        filterState.completion === 'both' || 
                        (filterState.completion === 'completed' && subtask.completed) ||
                        (filterState.completion === 'incomplete' && !subtask.completed);
                    
                    if ((isAssignedToUser || (isUnassigned && parentAssignedToUser)) && matchesCompletionFilter) {
                        // Preserve existing comments and UI state if subtask already exists
                        const existingSubtask = allTasksMap.get(subtask.gid);
                        if (existingSubtask) {
                            subtask.comments = existingSubtask.comments;
                            subtask.notesExpanded = existingSubtask.notesExpanded;
                            subtask.commentsShown = existingSubtask.commentsShown;
                            subtask.subtasks = existingSubtask.subtasks || [];
                            subtask.subtasksLoaded = existingSubtask.subtasksLoaded || false;
                        } else {
                            subtask.subtasks = [];
                            subtask.comments = null;
                            subtask.subtasksLoaded = false;
                        }
                        
                        allTasksMap.set(subtask.gid, subtask);
                        task.subtasks.push(subtask);
                        
                        await loadSubtasksFiltered(subtask.gid, isAssignedToUser);
                    }
                }
            } catch (error) {
                console.error('Error loading subtasks:', error);
            }
        }

        function displayTasks() {
            // Save current scroll position
            const scrollY = window.scrollY || window.pageYOffset;
            const scrollX = window.scrollX || window.pageXOffset;
            
            const content = document.getElementById('content');

            // Apply parent filter
            let tasksToDisplay = rootItems;
            if (filterState.parentFilter) {
                // Filter to show only tasks that are the selected parent OR descendants of it
                tasksToDisplay = rootItems.filter(task => {
                    if (task.gid === filterState.parentFilter) {
                        return true; // This IS the parent
                    }
                    // Check if this task is a descendant of the filter parent
                    return isDescendantOf(task.gid, filterState.parentFilter);
                });
            }

            // Apply date range filter (client-side)
            tasksToDisplay = filterTasksByDate(tasksToDisplay);

            // Apply completion status filter
            tasksToDisplay = filterTasksByCompletion(tasksToDisplay);

            // Collapse single-child chains after filtering
            // (filtering may have removed children, creating new single-child chains)
            tasksToDisplay = collapseSingleChildChainsInArray(tasksToDisplay);

            // Apply sorting
            tasksToDisplay = sortTasks(tasksToDisplay);

            if (tasksToDisplay.length === 0) {
                content.innerHTML = '<div style="text-align: center; padding: 40px; color: #6c757d;">No tasks found with current filters.</div>';
                // Restore scroll immediately
                window.scrollTo(scrollX, scrollY);
                return;
            }
            
            // Build all content in a document fragment first
            const fragment = document.createDocumentFragment();
            tasksToDisplay.forEach(task => {
                const taskElement = renderTask(task, 0, true);
                fragment.appendChild(taskElement);
            });
            
            // Replace content all at once
            content.innerHTML = '';
            content.appendChild(fragment);

            updateSummary(tasksToDisplay);
            
            // Defer scroll restoration until after browser finishes layout
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    window.scrollTo(scrollX, scrollY);
                });
            });
        }

        function filterTasksByCompletion(tasks) {
            debugLog('filterTasksByCompletion called with', tasks.length, 'tasks');
            debugLog('Completion filter mode:', filterState.completion);
            
            if (filterState.completion === 'both') {
                debugLog('Filter mode is "both" - returning all tasks');
                return tasks;
            }

            const showCompleted = filterState.completion === 'completed';
            debugLog('Show completed:', showCompleted);

            // Collect all matching tasks from the entire tree
            const matchingTasks = [];
            
            function collectMatching(task, parentChain = []) {
                // Projects and sections are containers - check their children
                if (task.isProject || task.isSection || task.isPlaceholder) {
                    if (task.subtasks && task.subtasks.length > 0) {
                        // Add this container to the parent chain
                        const newParentChain = [...parentChain, {gid: task.gid, name: task.name}];
                        task.subtasks.forEach(st => collectMatching(st, newParentChain));
                    }
                    return;
                }
                
                // Check if this real task matches the filter
                const matches = task.completed === showCompleted;
                
                if (matches) {
                    // This task matches - add it with its parent chain
                    matchingTasks.push({
                        task: task,
                        parentChain: parentChain
                    });
                }
                
                // Recurse into subtasks
                if (task.subtasks && task.subtasks.length > 0) {
                    const newParentChain = [...parentChain, {gid: task.gid, name: task.name}];
                    task.subtasks.forEach(st => collectMatching(st, newParentChain));
                }
            }
            
            // Collect all matching tasks from all root items
            // Use collapsedParentChain if it exists to maintain proper parent chain context
            tasks.forEach(task => collectMatching(task, task.collapsedParentChain || []));
            
            debugLog('Found', matchingTasks.length, 'matching tasks');
            
            // Group tasks by common parent chain prefixes
            function findCommonPrefixLength(chain1, chain2) {
                let i = 0;
                while (i < chain1.length && i < chain2.length && chain1[i].gid === chain2[i].gid) {
                    i++;
                }
                return i;
            }
            
            function groupByCommonPrefix() {
                const groups = [];
                const ungrouped = [];
                const processed = new Set();
                
                for (let i = 0; i < matchingTasks.length; i++) {
                    if (processed.has(i)) continue;
                    
                    const current = matchingTasks[i];
                    const group = [i];
                    let maxCommonLength = 0;
                    
                    // Find all other tasks that share a common prefix with this one
                    for (let j = i + 1; j < matchingTasks.length; j++) {
                        if (processed.has(j)) continue;
                        
                        const other = matchingTasks[j];
                        const commonLength = findCommonPrefixLength(current.parentChain, other.parentChain);
                        
                        if (commonLength > 0) {
                            group.push(j);
                            maxCommonLength = Math.max(maxCommonLength, commonLength);
                        }
                    }
                    
                    if (group.length > 1) {
                        // This group has multiple tasks sharing a prefix
                        group.forEach(idx => processed.add(idx));
                        
                        // Find the actual common prefix length for all tasks in the group
                        let actualCommonLength = matchingTasks[group[0]].parentChain.length;
                        for (let k = 1; k < group.length; k++) {
                            actualCommonLength = findCommonPrefixLength(
                                matchingTasks[group[0]].parentChain,
                                matchingTasks[group[k]].parentChain
                            );
                        }
                        
                        groups.push({
                            indices: group,
                            commonPrefixLength: actualCommonLength
                        });
                    } else {
                        // Single task, no grouping needed
                        processed.add(i);
                        ungrouped.push(i);
                    }
                }
                
                return { groups, ungrouped };
            }
            
            const { groups, ungrouped } = groupByCommonPrefix();
            
            debugLog('Grouped:', groups.length, 'groups, Ungrouped:', ungrouped.length, 'tasks');
            
            // Now build the result hierarchy
            // Tasks with no parents or all parents matching stay in hierarchy
            // Tasks with any non-matching parent get promoted to root level with breadcrumbs
            // Tasks in groups get nested under their common parent
            
            function buildFilteredHierarchy() {
                const result = [];
                const processed = new Set();
                
                // First, handle grouped tasks
                for (const group of groups) {
                    const firstTaskData = matchingTasks[group.indices[0]];
                    const commonPrefix = firstTaskData.parentChain.slice(0, group.commonPrefixLength);
                    
                    // Get the deepest common parent
                    const commonParentInfo = commonPrefix[commonPrefix.length - 1];
                    const commonParentTask = allTasksMap.get(commonParentInfo.gid);
                    
                    // Create a container for this common parent
                    const container = {
                        gid: commonParentInfo.gid,
                        name: commonParentInfo.name,
                        isGroupedContainer: true,
                        isProject: commonParentTask?.isProject || false,
                        isSection: commonParentTask?.isSection || false,
                        isPlaceholder: commonParentTask?.isPlaceholder || false,
                        completed: false,
                        collapsedParentChain: commonPrefix.slice(0, -1), // Everything before this parent
                        subtasks: []
                    };
                    
                    // Add each task in the group as a child of this container
                    for (const idx of group.indices) {
                        const { task, parentChain } = matchingTasks[idx];
                        processed.add(task.gid);
                        
                        // The remaining chain after the common prefix
                        const remainingChain = parentChain.slice(group.commonPrefixLength);
                        
                        // If there's a remaining chain, we need to build intermediate containers
                        if (remainingChain.length > 0) {
                            // Build nested structure for remaining chain
                            let currentContainer = container;
                            
                            for (let i = 0; i < remainingChain.length; i++) {
                                const chainItem = remainingChain[i];
                                
                                // Check if this container already exists in current level
                                let existingContainer = currentContainer.subtasks.find(
                                    st => st.gid === chainItem.gid
                                );
                                
                                if (!existingContainer) {
                                    const chainTask = allTasksMap.get(chainItem.gid);
                                    existingContainer = {
                                        gid: chainItem.gid,
                                        name: chainItem.name,
                                        isGroupedContainer: true,
                                        isProject: chainTask?.isProject || false,
                                        isSection: chainTask?.isSection || false,
                                        isPlaceholder: chainTask?.isPlaceholder || false,
                                        completed: chainTask?.completed || false,
                                        subtasks: []
                                    };
                                    currentContainer.subtasks.push(existingContainer);
                                }
                                
                                currentContainer = existingContainer;
                            }
                            
                            // Add the final task to the deepest container
                            currentContainer.subtasks.push({
                                ...task,
                                subtasks: filterSubtasks(task)
                            });
                        } else {
                            // No remaining chain, add task directly
                            container.subtasks.push({
                                ...task,
                                subtasks: filterSubtasks(task)
                            });
                        }
                    }
                    
                    result.push(container);
                }
                
                // Then handle ungrouped tasks (original logic)
                for (const idx of ungrouped) {
                    const {task, parentChain} = matchingTasks[idx];
                    if (processed.has(task.gid)) continue;
                    
                    // Check if all parents match the filter
                    let allParentsMatch = true;
                    for (const parent of parentChain) {
                        const parentTask = allTasksMap.get(parent.gid);
                        if (parentTask && !parentTask.isProject && !parentTask.isSection && !parentTask.isPlaceholder) {
                            // This is a real task parent - check if it matches
                            if (parentTask.completed !== showCompleted) {
                                allParentsMatch = false;
                                break;
                            }
                        }
                    }
                    
                    if (!allParentsMatch || parentChain.length === 0) {
                        // Promote to root level with breadcrumbs
                        const promoted = {
                            ...task,
                            collapsedParentChain: parentChain,
                            subtasks: filterSubtasks(task)
                        };
                        result.push(promoted);
                        processed.add(task.gid);
                    } else {
                        // All parents match - keep in hierarchy
                        // This will be handled by building the hierarchy from the top
                    }
                }
                
                // For tasks that should stay in hierarchy, we need to build the tree properly
                // Start from roots and build down, only including matching tasks or containers with 2+ matching descendants
                function buildFromRoot(task) {
                    if (task.isProject || task.isSection || task.isPlaceholder) {
                        // This is a container - recursively build its children
                        const filteredSubs = [];
                        if (task.subtasks) {
                            for (const sub of task.subtasks) {
                                const built = buildFromRoot(sub);
                                if (built) filteredSubs.push(built);
                            }
                        }
                        
                        // Count total real task descendants (recursively)
                        function countRealTaskDescendants(items) {
                            let count = 0;
                            for (const item of items) {
                                if (item.isProject || item.isSection || item.isPlaceholder) {
                                    // This is a container - count its descendants
                                    if (item.subtasks && item.subtasks.length > 0) {
                                        count += countRealTaskDescendants(item.subtasks);
                                    }
                                } else {
                                    // This is a real task
                                    count++;
                                }
                            }
                            return count;
                        }
                        
                        const totalDescendants = countRealTaskDescendants(filteredSubs);
                        
                        // Only include container if it has 2+ real task descendants (counting recursively)
                        if (totalDescendants >= 2) {
                            return {...task, subtasks: filteredSubs};
                        }
                        // If < 2 real task descendants, don't include this container
                        // The real tasks within will be promoted to root level
                        return null;
                    }
                    
                    if (processed.has(task.gid)) return null; // Already promoted
                    
                    // This is a regular task - only include if it matches the filter
                    if (task.completed === showCompleted) {
                        processed.add(task.gid);
                        return {
                            ...task,
                            subtasks: filterSubtasks(task)
                        };
                    }
                    
                    // Task doesn't match filter - don't include it
                    // But check if it has matching descendants that should be promoted
                    if (task.subtasks && task.subtasks.length > 0) {
                        // Recursively check for matching descendants
                        for (const sub of task.subtasks) {
                            buildFromRoot(sub); // This will handle promotion if needed
                        }
                    }
                    
                    return null;
                }
                
                for (const rootTask of tasks) {
                    const built = buildFromRoot(rootTask);
                    if (built) result.push(built);
                }
                
                return result;
            }
            
            function filterSubtasks(task) {
                if (!task.subtasks || task.subtasks.length === 0) return [];
                
                const filtered = [];
                for (const sub of task.subtasks) {
                    if (sub.isProject || sub.isSection || sub.isPlaceholder) {
                        const filteredSubs = filterSubtasks(sub);
                        if (filteredSubs.length > 0) {
                            filtered.push({...sub, subtasks: filteredSubs});
                        }
                    } else if (sub.completed === showCompleted) {
                        filtered.push({
                            ...sub,
                            subtasks: filterSubtasks(sub)
                        });
                    }
                }
                return filtered;
            }
            
            const result = buildFilteredHierarchy();
            
            debugLog('After filtering:', result.length, 'tasks remain');
            debugLog('Sample tasks:', result.slice(0, 3).map(t => ({name: t.name, completed: t.completed})));
            
            return result;
        }

        function sortTasks(tasks) {
            // Get all active sort columns with their priorities
            const sortColumns = Object.entries(sortState.columns)
                .filter(([_, state]) => state.order !== 'none')
                .sort((a, b) => a[1].priority - b[1].priority)
                .map(([field, state]) => ({ field, order: state.order }));
            
            // If no active sorts, return original order
            if (sortColumns.length === 0) {
                return tasks;
            }
            
            // Create a copy to sort
            const sorted = [...tasks];
            
            sorted.sort((a, b) => {
                // Try each sort column in priority order
                for (const column of sortColumns) {
                    const field = column.field;
                    const order = column.order;
                    let comparison = 0;
                    
                    switch (field) {
                        case 'name':
                            comparison = a.name.localeCompare(b.name);
                            break;
                            
                        case 'due_date':
                            if (!a.due_on && !b.due_on) comparison = 0;
                            else if (!a.due_on) comparison = 1;
                            else if (!b.due_on) comparison = -1;
                            else comparison = new Date(a.due_on) - new Date(b.due_on);
                            break;
                            
                        case 'completed':
                            if (a.completed === b.completed) comparison = 0;
                            else comparison = a.completed ? 1 : -1;
                            break;
                            
                        case 'modified':
                            if (!a.modified_at && !b.modified_at) comparison = 0;
                            else if (!a.modified_at) comparison = 1;
                            else if (!b.modified_at) comparison = -1;
                            else comparison = new Date(b.modified_at) - new Date(a.modified_at);
                            break;
                    }
                    
                    // If values are not equal, return sort result
                    if (comparison !== 0) {
                        return order === 'asc' ? comparison : -comparison;
                    }
                    
                    // If equal, continue to next column
                }
                
                return 0; // All values were equal
            });
            
            return sorted;
        }

        function applySorting() {
            displayTasks();
        }

        function updateSummary(tasks) {
            let totalTasks = 0;
            let completedTasks = 0;

            function countTasks(task) {
                totalTasks++;
                if (task.completed) completedTasks++;
                if (task.subtasks) {
                    task.subtasks.forEach(countTasks);
                }
            }

            tasks.forEach(countTasks);

            // Determine data source status
            let dataSourceStatus;
            if (window.backgroundLoadingInProgress) {
                dataSourceStatus = 'Displaying from local cache; Refreshing...';
            } else if (window.lastRefreshTime) {
                const timeStr = window.lastRefreshTime.toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });
                dataSourceStatus = `Refreshed from Asana at ${timeStr}`;
            } else {
                dataSourceStatus = 'Data source unknown';
            }
            
            // Store info for modal
            window.taskDebugInfo = {
                completionFilter: filterState.completion,
                dateFilter: filterState.dateRange,
                rootItems: rootItems.length,
                afterFilters: tasks.length,
                totalTasks: totalTasks,
                completedTasks: completedTasks,
                remainingTasks: totalTasks - completedTasks,
                dataSource: dataSourceStatus
            };
            
            // Summary bar now only shows basic count info
            document.getElementById('summary').innerHTML = '';
        }

        // Recursive function to check if all descendants are complete
        function areAllDescendantsComplete(task) {
            const isNonTask = task.isSection || task.isProject || task.isPlaceholder;
            
            // For non-tasks, only check descendants (they don't have their own completion status)
            // For real tasks, if the task itself is marked complete, all its descendants are considered complete
            if (!isNonTask && task.completed) {
                return true;
            }
            
            if (!task.subtasks || task.subtasks.length === 0) {
                // Leaf task: check its own completion status
                // Non-tasks with no subtasks should return true (empty container is "complete")
                return isNonTask ? true : task.completed;
            }
            
            // Has subtasks: check if all visible subtasks would be DISPLAYED as complete
            // Get filtered subtasks based on current completion filter
            const filteredSubtasks = task.subtasks.filter(subtask => 
                shouldDisplayTask(subtask, filterState.completion)
            );
            
            // If no visible subtasks, treat as complete
            if (filteredSubtasks.length === 0) {
                return true;
            }
            
            // Check if all visible subtasks would be displayed as complete
            // A subtask is displayed as complete if:
            // 1. It's actually completed, OR
            // 2. It's a container where all ITS visible descendants are complete (recursive)
            return filteredSubtasks.every(st => {
                const subtask = allTasksMap.get(st.gid);
                if (!subtask) return false;
                
                // If subtask is completed, it's displayed as complete
                if (subtask.completed) return true;
                
                // If subtask is a structural non-task, check its descendants
                const subtaskIsNonTask = subtask.isSection || subtask.isProject || subtask.isPlaceholder;
                if (subtaskIsNonTask) {
                    return areAllDescendantsComplete(subtask);
                }
                
                // If subtask is a regular task with subtasks, check if all ITS visible descendants are complete
                if (subtask.subtasks && subtask.subtasks.length > 0) {
                    // Recursively check if this subtask would be displayed as complete
                    return areAllDescendantsComplete(subtask);
                }
                
                // Regular task without subtasks: check its completion status
                return subtask.completed;
            });
        }

        function renderTask(task, level, isRoot = false) {
            // Check if this is a structural non-task (section, project, placeholder, or grouped container)
            const isStructuralNonTask = task.isSection || task.isProject || task.isPlaceholder || task.isGroupedContainer;
            
            // Check if all visible descendants are complete (applies to all tasks with subtasks)
            let allVisibleDescendantsComplete = false;
            if (task.subtasks && task.subtasks.length > 0) {
                // Get filtered subtasks based on current completion filter
                const filteredSubtasks = task.subtasks.filter(subtask => 
                    shouldDisplayTask(subtask, filterState.completion)
                );
                
                // If we have filtered subtasks, check if they're all completed
                if (filteredSubtasks.length > 0) {
                    allVisibleDescendantsComplete = filteredSubtasks.every(st => areAllDescendantsComplete(st));
                }
            }
            
            // Determine if this should be treated as a container (no checkbox)
            // Either structural non-task OR regular task with all visible descendants complete
            const shouldTreatAsContainer = !isStructuralNonTask && allVisibleDescendantsComplete;
            const isNonTask = isStructuralNonTask || shouldTreatAsContainer;
            
            // Determine display completion status
            // Style as completed if: task itself is completed OR (is container AND all visible descendants are complete)
            const displayAsCompleted = task.completed || (isNonTask && allVisibleDescendantsComplete);
            
            const div = document.createElement('div');
            div.className = `task-item ${displayAsCompleted ? 'completed' : ''}`;
            div.style.marginLeft = (level * 5) + 'px';
            div.dataset.taskId = task.gid;

            // Determine if item should be expandable (has any content besides name)
            const hasSubtasks = task.subtasks && task.subtasks.length > 0;
            const hasNotes = task.notes && task.notes.trim().length > 0;
            const hasComments = task.comments && task.comments.length > 0;
            const hasAssignee = task.assignee && task.assignee.name;
            const hasDueDate = task.due_on;
            
            // Item is expandable if it has subtasks, notes, or comments
            const isExpandable = hasSubtasks || hasNotes || hasComments;
            
            // Item should show expand/collapse UI only if expandable AND has other fields
            const showExpandUI = isExpandable && (hasAssignee || hasDueDate || hasNotes || hasComments || hasSubtasks);
            
            // Check if this task should be expanded (from saved state only)
            let isExpanded = false;
            if (expandStates[task.gid] !== undefined) {
                isExpanded = expandStates[task.gid];
            }
            
            // Calculate descendant count (direct children only)
            const descendantCount = hasSubtasks ? task.subtasks.length : 0;
            const descendantBadge = descendantCount > 0 ? `<span style="color: #6c757d; font-size: 0.85em; margin-left: 4px;">  ${descendantCount} ‚ÅÇ</span>` : '';
            
            // Only show expand icon if item is actually expandable
            const expandIcon = showExpandUI ? `<span class="expand-icon" onclick="toggleTaskExpand(event, '${task.gid}')">${isExpanded ? '‚ñº' : '‚ñ∂'}</span>` : '<span class="expand-icon"></span>';

            // Due date button (always shown on right side)
            let dueDateDisplay = task.due_on ? `üìÖ ${task.due_on}` : 'üìÖ Add Due Date';
            let dueDateClass = '';
            let dueDateStyle = task.due_on ? 'opacity: 1; pointer-events: auto;' : '';
            if (task.due_on) {
                const dueDate = new Date(task.due_on);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const isOverdue = dueDate < today && !displayAsCompleted;
                dueDateClass = isOverdue ? 'overdue' : '';
            }

            let breadcrumbHtml = '';
            // Show full parent hierarchy for root items
            if (isRoot) {
                let parentChain;
                
                // If this task has a collapsed parent chain (from filtering or single-child collapse),
                // use ONLY that chain - don't concatenate with getParentChainFromMap
                if (task.collapsedParentChain && task.collapsedParentChain.length > 0) {
                    parentChain = task.collapsedParentChain;
                } else {
                    // Otherwise, walk up the parent chain from allTasksMap
                    parentChain = getParentChainFromMap(task.gid);
                }
                
                if (parentChain.length > 0) {
                    breadcrumbHtml = '<div class="breadcrumb">';
                    
                    // Add all parents in the chain
                    breadcrumbHtml += parentChain.map(p => 
                        `<span style="color: #6c757d;">${escapeHtml(p.name)}</span>`
                    ).join(' ‚Üí ');
                    breadcrumbHtml += ' ‚Üí ';
                    
                    // Add current task name (slightly darker)
                    breadcrumbHtml += `<span style="color: #495057; font-weight: 500;">${escapeHtml(task.name)}</span>`;
                    breadcrumbHtml += '</div>';
                }
            }

            div.innerHTML = `
                ${breadcrumbHtml}
                <div class="task-header" ${showExpandUI ? `onclick="toggleTaskExpand(event, '${task.gid}')"` : ''}>
                    <div class="task-header-main">
                        ${expandIcon}
                        ${!isNonTask ? `<input type="checkbox" class="task-checkbox" 
                               ${task.completed ? 'checked' : ''} 
                               onclick="toggleTaskCompletion(event, '${task.gid}')" />` : ''}
                        <span class="task-name ${displayAsCompleted ? 'completed' : ''}">${escapeHtml(task.name)}</span>
                        <span class="task-meta">${descendantBadge}</span>
                        ${tasksBeingLoaded.has(task.gid) ? '<span class="task-loading-spinner" title="Loading..."></span>' : ''}
                        <span class="background-update-spinner"></span>
                    </div>
                    <div class="task-header-buttons">
                        <button class="btn-action due-date ${dueDateClass}" onclick="setDueDate(event, '${task.gid}')" style="${dueDateStyle}" title="Set Due Date">${dueDateDisplay}</button>
                        ${!hasNotes && !task.isProject && !task.isSection && !task.isPlaceholder ? '<button class="btn-action" onclick="editTaskNotes(event, \''+task.gid+'\')" title="Add Notes">üìù Notes</button>' : ''}
                        <button class="btn-action rename" onclick="renameTask(event, '${task.gid}')" title="Rename">‚úèÔ∏è Rename</button>
                        <button class="btn-action" onclick="createSubtask(event, '${task.gid}')" title="Add Subtask">‚ûï Subtask</button>
                        ${isNonTask && !allVisibleDescendantsComplete ? '<button class="btn-action btn-mark-all-complete" onclick="markAllDescendantsComplete(event, \''+task.gid+'\')" title="Mark all descendants complete">‚úì Mark all complete</button>' : ''}
                    </div>
                </div>
                <div id="details-${task.gid}" class="task-details" style="display: ${isExpanded ? 'block' : 'none'};">
                    ${isExpanded && window.backgroundLoadingInProgress ? '<div class="background-loading-spinner" style="padding: 8px; color: #6c757d; font-size: 0.9em; border-bottom: 1px solid #dee2e6; margin-bottom: 10px;"><div class="spinner" style="display: inline-block; width: 14px; height: 14px; margin-right: 6px; border: 2px solid #f3f3f3; border-top: 2px solid #2c7873; border-radius: 50%; animation: spin 1s linear infinite;"></div>Updating...</div>' : ''}
                </div>
            `;

            // If expanded, trigger rendering of details after element is added to DOM
            if (isExpanded) {
                setTimeout(async () => {
                    const detailsDiv = document.getElementById(`details-${task.gid}`);
                    if (!detailsDiv) return;
                    
                    // Check if there's already a spinner from the initial render
                    const hasSpinner = detailsDiv.querySelector('.background-loading-spinner');
                    
                    // Check if background loading is in progress - add spinner if not already there
                    if (window.backgroundLoadingInProgress && !hasSpinner) {
                        const spinnerDiv = document.createElement('div');
                        spinnerDiv.className = 'background-loading-spinner';
                        spinnerDiv.style.cssText = 'padding: 8px; color: #6c757d; font-size: 0.9em; border-bottom: 1px solid #dee2e6; margin-bottom: 10px;';
                        spinnerDiv.innerHTML = '<div class="spinner" style="display: inline-block; width: 14px; height: 14px; margin-right: 6px; border: 2px solid #f3f3f3; border-top: 2px solid #2c7873; border-radius: 50%; animation: spin 1s linear infinite;"></div>Updating...';
                        detailsDiv.appendChild(spinnerDiv);
                    }
                    
                    // Load comments if not loaded (only for actual tasks, not projects/sections)
                    if (!task.comments && !task.isProject && !task.isSection && !task.isPlaceholder) {
                        await loadComments(task.gid);
                    }
                    
                    // Load subtasks if not loaded
                    if (!task.subtasksLoaded) {
                        const isAssignedToUser = task.assignee && task.assignee.gid === currentUserId;
                        await loadSubtasksFiltered(task.gid, isAssignedToUser);
                    }
                    
                    await renderTaskDetails(task.gid);
                }, 0);
            }

            return div;
        }

        function getParentChainFromMap(taskGid) {
            const chain = [];
            const task = allTasksMap.get(taskGid);
            if (!task) return chain;

            // First, try to build chain from task parent relationships
            if (task.parent) {
                let currentGid = task.parent.gid;
                const visited = new Set(); // Prevent infinite loops
                
                while (currentGid && !visited.has(currentGid)) {
                    visited.add(currentGid);
                    const parent = allTasksMap.get(currentGid);
                    if (!parent) break;
                    chain.unshift(parent);
                    currentGid = parent.parent ? parent.parent.gid : null;
                }
            }
            
            // If chain is still empty, try to build from project/section memberships
            if (chain.length === 0 && task.memberships && task.memberships.length > 0) {
                // Get the first membership (tasks can be in multiple projects)
                const membership = task.memberships[0];
                
                // Add project to chain
                if (membership.project && membership.project.name) {
                    chain.push({
                        gid: membership.project.gid,
                        name: membership.project.name,
                        isProject: true
                    });
                }
                
                // Add section to chain (if exists)
                if (membership.section && membership.section.name) {
                    chain.push({
                        gid: membership.section.gid,
                        name: membership.section.name,
                        isSection: true
                    });
                }
            }

            return chain;
        }

        function isDescendantOf(taskGid, ancestorGid) {
            // Check if taskGid is a descendant of ancestorGid by walking up the parent chain
            const task = allTasksMap.get(taskGid);
            if (!task || !task.parent) return false;

            let currentGid = task.parent.gid;
            const visited = new Set(); // Prevent infinite loops
            
            while (currentGid && !visited.has(currentGid)) {
                if (currentGid === ancestorGid) {
                    return true; // Found the ancestor
                }
                visited.add(currentGid);
                const parent = allTasksMap.get(currentGid);
                if (!parent) break;
                currentGid = parent.parent ? parent.parent.gid : null;
            }

            return false;
        }

        function filterByParent(parentGid) {
            filterState.parentFilter = parentGid;
            saveFilterState();
            displayTasks();
            displayFilterBadges();
            document.getElementById('parentFilter').value = parentGid;
        }

        async function toggleTaskExpand(event, taskGid) {
            // Don't toggle if clicking on checkbox or edit button
            if (event.target.classList.contains('task-checkbox') || 
                event.target.classList.contains('btn-edit')) {
                return;
            }

            event.stopPropagation();
            
            const taskElement = document.querySelector(`[data-task-id="${taskGid}"]`);
            const detailsDiv = document.getElementById('details-' + taskGid);
            const task = allTasksMap.get(taskGid);
            const icon = taskElement ? taskElement.querySelector('.expand-icon') : null;

            if (!task || !detailsDiv) return;

            const isExpanded = detailsDiv.style.display !== 'none';

            if (isExpanded) {
                // Collapse
                detailsDiv.style.display = 'none';
                if (icon) icon.textContent = '‚ñ∂';
                expandStates[taskGid] = false;
            } else {
                // Expand
                detailsDiv.style.display = 'block';
                if (icon) icon.textContent = '‚ñº';
                expandStates[taskGid] = true;

                // Check if details div already has content (from previous expansion)
                const hasRenderedContent = detailsDiv.innerHTML.trim().length > 0 && 
                                          !detailsDiv.querySelector('.loading-indicator');

                // If already rendered, just show it - don't reload unless needed
                if (hasRenderedContent) {
                    // Content already exists, just make it visible
                } else {
                    // Need to load/render content
                    // Mark task as loading and add spinner
                    tasksBeingLoaded.add(taskGid);
                    const taskNameSpan = taskElement.querySelector('.task-name');
                    if (taskNameSpan && !taskNameSpan.parentElement.querySelector('.task-loading-spinner')) {
                        const spinner = document.createElement('span');
                        spinner.className = 'task-loading-spinner';
                        spinner.title = 'Loading...';
                        taskNameSpan.parentElement.appendChild(spinner);
                    }

                    // Check if background loading is in progress
                    const isBackgroundLoading = window.backgroundLoadingInProgress;
                    
                    // If task has cached content (notes, comments, or subtasks), show it immediately
                    const hasCachedContent = (task.notes && task.notes.trim().length > 0) || 
                                            (task.html_notes && task.html_notes.trim().length > 0) ||
                                            (task.comments && task.comments.length > 0) ||
                                            (task.subtasks && task.subtasks.length > 0);
                    
                    if (hasCachedContent) {
                        // Render cached content immediately
                        await renderTaskDetails(taskGid);
                    } else {
                        // No cached content, show loading indicator
                        detailsDiv.innerHTML = '<div class="loading-indicator" style="padding: 10px 0 10px 40px; color: #6c757d;"><div class="spinner" style="display: inline-block; width: 16px; height: 16px; margin-right: 8px;"></div>Loading...</div>';
                    }

                    // Track whether we need to load new data
                    let needsDataLoad = false;

                    // Load comments if not loaded (only for actual tasks, not projects/sections)
                    if (!task.comments && !task.isProject && !task.isSection && !task.isPlaceholder) {
                        await loadComments(taskGid);
                        needsDataLoad = true;
                    }

                    // Load subtasks if not loaded
                    if (!task.subtasksLoaded) {
                        const isAssignedToUser = task.assignee && task.assignee.gid === currentUserId;
                        await loadSubtasksFiltered(task.gid, isAssignedToUser);
                        needsDataLoad = true;
                    }

                    // Only re-render if we loaded new data OR if we didn't have cached content initially
                    if (needsDataLoad || !hasCachedContent) {
                        await renderTaskDetails(taskGid);
                    }
                    
                    // Remove loading state and spinner
                    tasksBeingLoaded.delete(taskGid);
                    const loadingSpinner = taskElement.querySelector('.task-loading-spinner');
                    if (loadingSpinner) {
                        loadingSpinner.remove();
                    }
                }
            }
            
            saveExpandStates();
        }

        // Helper function to check if a task should be displayed based on completion filter
        function shouldDisplayTask(task, completionFilter) {
            // Non-tasks (projects, sections, placeholders, grouped containers) are containers
            // Show them if they have any matching descendants
            if (task.isProject || task.isSection || task.isPlaceholder || task.isGroupedContainer) {
                if (!task.subtasks || task.subtasks.length === 0) return false;
                return task.subtasks.some(st => shouldDisplayTask(st, completionFilter));
            }
            
            // For real tasks, check completion status
            if (completionFilter === 'both') {
                return true; // Show all tasks
            } else if (completionFilter === 'completed') {
                // Show if completed, OR has completed descendants
                if (task.completed) return true;
                if (!task.subtasks || task.subtasks.length === 0) return false;
                return task.subtasks.some(st => shouldDisplayTask(st, completionFilter));
            } else if (completionFilter === 'uncompleted') {
                // Show if not completed, OR has incomplete descendants
                if (!task.completed) return true;
                if (!task.subtasks || task.subtasks.length === 0) return false;
                return task.subtasks.some(st => shouldDisplayTask(st, completionFilter));
            }
            
            return true; // Default to showing
        }

        async function renderTaskDetails(taskGid) {
            const task = allTasksMap.get(taskGid);
            const detailsDiv = document.getElementById('details-' + taskGid);
            if (!task || !detailsDiv) return;

            // Initialize comment display count if not set
            if (!task.commentsShown) {
                task.commentsShown = 3; // Show 3 most recent by default
            }

            let contentHtml = '';

            // Notes section
            if ((task.notes && task.notes.trim().length > 0) || (task.html_notes && task.html_notes.trim().length > 0)) {
                // Full rich text for expanded view
                let richTextContent;
                if (task.html_notes) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(task.html_notes, 'text/html');
                    richTextContent = doc.body.innerHTML;
                } else {
                    richTextContent = linkifyHTML(task.notes || '');
                }
                
                // Stripped HTML for collapsed view (preserves links, lists, but removes styling)
                const collapsedContent = task.html_notes ? stripHtmlStyling(task.html_notes) : linkifyHTML(task.notes || '');
                
                // Always start collapsed (expansion state is not persisted)
                task.notesExpanded = false;
                
                contentHtml += `
                    <div class="notes-container" style="padding-left: 5px;">
                        <strong>Notes:</strong>
                        <div style="position: relative; margin-top: 5px;">
                            <button class="btn-edit" onclick="editTaskNotes(event, '${task.gid}')" style="position: absolute; top: 10px; right: 10px; z-index: 10;">Edit</button>
                            <div id="notes-${task.gid}" class="notes-content ${task.notesExpanded ? '' : 'collapsed'}" style="padding: 10px; background: white; border-radius: 4px; margin-bottom: 0;">${task.notesExpanded ? richTextContent : collapsedContent}</div>
                        </div>
                        <button class="show-more-btn" onclick="toggleNotesExpansion(event, '${task.gid}')" style="display: none;">${task.notesExpanded ? 'Show Less' : 'Show More'}</button>
                    </div>
                `;
            }

            // Comments section with pagination
            if (task.comments && task.comments.length > 0) {
                contentHtml += '<div style="padding-left: 5px; margin-top: 15px; margin-bottom: 15px;"><h4>Comments</h4>';
                
                // Sort comments by date (oldest first for chronological display)
                const sortedComments = [...task.comments].sort((a, b) => 
                    new Date(a.created_at) - new Date(b.created_at)
                );
                
                const totalComments = sortedComments.length;
                const commentsToShow = Math.min(task.commentsShown, totalComments);
                const hasMoreComments = commentsToShow < totalComments;
                
                // Show "earlier comments" link if there are more
                if (hasMoreComments) {
                    const hiddenCount = totalComments - commentsToShow;
                    contentHtml += `
                        <div style="margin-bottom: 10px;">
                            <a href="#" onclick="showEarlierComments(event, '${taskGid}'); return false;" 
                               style="color: #2c7873; text-decoration: none; font-size: 0.9em;">
                                ‚Üë Show ${Math.min(5, hiddenCount)} earlier comment${Math.min(5, hiddenCount) > 1 ? 's' : ''}
                            </a>
                        </div>
                    `;
                }
                
                // Calculate which comments to display
                // Skip the oldest (totalComments - commentsToShow) and show the rest
                const commentsToDisplay = sortedComments.slice(totalComments - commentsToShow);
                
                // Display comments in chronological order
                commentsToDisplay.forEach(comment => {
                    // Rich text for expanded view
                    const richCommentText = comment.html_text || linkifyHTML(comment.text);
                    // Stripped HTML for collapsed view (preserves links, lists, but removes styling)
                    const collapsedCommentText = comment.html_text ? stripHtmlStyling(comment.html_text) : linkifyHTML(comment.text);
                    
                    // Always start collapsed (expansion state is not persisted)
                    comment.expanded = false;
                    
                    // Only show edit/delete buttons if current user created the comment
                    const isOwnComment = comment.created_by.gid === currentUserId;
                    const actionButtons = isOwnComment ? `
                        <div>
                            <button class="btn-edit" onclick="editComment(event, '${taskGid}', '${comment.gid}')">Edit</button>
                            <button class="btn-delete" onclick="deleteComment(event, '${taskGid}', '${comment.gid}')">Delete</button>
                        </div>
                    ` : '';
                    
                    contentHtml += `
                        <div class="comment" style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 4px; position: relative;">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div>
                                    <div style="font-weight: 600; font-size: 0.9em;">${escapeHtml(comment.created_by.name)}</div>
                                    <div style="color: #6c757d; font-size: 0.85em; margin-bottom: 5px;">${new Date(comment.created_at).toLocaleString()}</div>
                                </div>
                                ${actionButtons}
                            </div>
                            <div id="comment-content-${comment.gid}" class="comment-content ${comment.expanded ? '' : 'collapsed'}" style="background: #f8f9fa; border-radius: 4px; margin-top: 5px; padding: 10px;">${comment.expanded ? richCommentText : collapsedCommentText}</div>
                            <button class="show-more-btn" onclick="toggleCommentExpansion(event, '${taskGid}', '${comment.gid}')" style="display: none;">${comment.expanded ? 'Show Less' : 'Show More'}</button>
                            <div id="comment-edit-${comment.gid}" style="display: none;"></div>
                        </div>
                    `;
                });
                
                contentHtml += '</div>';
            }
            
            // Add comment section (only for actual tasks, not projects/sections)
            if (!task.isProject && !task.isSection && !task.isPlaceholder) {
                contentHtml += `
                    <div style="padding-left: 5px; margin-bottom: 15px;">
                        <div id="new-comment-${taskGid}" style="display: none; margin-top: 10px;">
                            <div class="editor-container">
                                <div id="comment-editor-${taskGid}"></div>
                            </div>
                            <div style="margin-top: 8px;">
                                <button class="btn-edit" onclick="saveComment('${taskGid}')" style="opacity: 1; pointer-events: auto;">Add Comment</button>
                                <button class="btn-secondary" onclick="cancelComment('${taskGid}')" style="margin-left: 8px;">Cancel</button>
                            </div>
                        </div>
                        <button class="btn-edit" id="add-comment-btn-${taskGid}" onclick="showCommentBox('${taskGid}')" style="margin-top: 10px; opacity: 1; pointer-events: auto;">Add Comment</button>
                    </div>
                `;
            }

            detailsDiv.innerHTML = contentHtml;

            // Render subtasks if they exist
            if (task.subtasks && task.subtasks.length > 0) {
                const level = parseInt(detailsDiv.closest('.task-item').style.marginLeft || '0') / 40;
                // Filter subtasks based on completion filter
                const filteredSubtasks = task.subtasks.filter(subtask => 
                    shouldDisplayTask(subtask, filterState.completion)
                );
                filteredSubtasks.forEach(subtask => {
                    const subtaskElement = renderTask(subtask, level + 1);
                    detailsDiv.appendChild(subtaskElement);
                });
            }

            // Check if Show More buttons are needed after DOM is updated
            setTimeout(() => checkAndUpdateShowMoreButtons(), 0);
        }

        function checkAndUpdateShowMoreButtons() {
            // Check all notes and comments to see if they actually overflow
            document.querySelectorAll('.notes-content.collapsed, .comment-content.collapsed').forEach(element => {
                const maxHeight = parseFloat(getComputedStyle(element).maxHeight);
                const actualHeight = element.scrollHeight;
                
                // Find the associated show more button
                // For notes: button is sibling of parent div
                // For comments: button is next sibling
                let showMoreBtn;
                if (element.classList.contains('notes-content')) {
                    // Notes structure: <div wrapper><button edit/><div notes-content/></div><button show-more/>
                    showMoreBtn = element.parentElement.nextElementSibling;
                } else {
                    // Comments structure: <div comment-content/><button show-more/>
                    showMoreBtn = element.nextElementSibling;
                }
                
                // Determine if content actually overflows
                const hasOverflow = actualHeight > maxHeight + 25;
                
                // Show/hide button based on overflow
                if (showMoreBtn && showMoreBtn.classList.contains('show-more-btn')) {
                    if (hasOverflow) {
                        showMoreBtn.style.display = 'inline-block';
                        element.classList.add('collapsed'); // Ensure collapsed class is present
                    } else {
                        showMoreBtn.style.display = 'none';
                        // Add a class to hide gradient but keep line-height
                        element.classList.add('no-gradient');
                    }
                }
            });
        }

        async function toggleNotesExpansion(event, taskGid) {
            event.preventDefault();
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            // Toggle expansion state
            task.notesExpanded = !task.notesExpanded;
            
            const notesDiv = document.getElementById(`notes-${taskGid}`);
            const button = event.target;
            
            if (!notesDiv) return;
            
            if (task.notesExpanded) {
                // Expand: show rich text
                notesDiv.classList.remove('collapsed');
                let richTextContent;
                if (task.html_notes) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(task.html_notes, 'text/html');
                    richTextContent = doc.body.innerHTML;
                } else {
                    richTextContent = linkifyHTML(task.notes || '');
                }
                notesDiv.innerHTML = richTextContent;
                button.textContent = 'Show Less';
            } else {
                // Collapse: show stripped HTML (preserves links, removes styling)
                notesDiv.classList.add('collapsed');
                const collapsedContent = task.html_notes ? stripHtmlStyling(task.html_notes) : linkifyHTML(task.notes || '');
                notesDiv.innerHTML = collapsedContent;
                button.textContent = 'Show More';
            }
        }

        async function toggleCommentExpansion(event, taskGid, commentGid) {
            event.preventDefault();
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            if (!task || !task.comments) return;
            
            // Find the comment and toggle its expanded state
            const comment = task.comments.find(c => c.gid === commentGid);
            if (!comment) return;
            
            comment.expanded = !comment.expanded;
            
            const commentDiv = document.getElementById(`comment-content-${commentGid}`);
            const button = event.target;
            
            if (!commentDiv) return;
            
            if (comment.expanded) {
                // Expand: show rich text
                commentDiv.classList.remove('collapsed');
                const richCommentText = comment.html_text || linkifyHTML(comment.text);
                commentDiv.innerHTML = richCommentText;
                button.textContent = 'Show Less';
            } else {
                // Collapse: show stripped HTML (preserves links, removes styling)
                commentDiv.classList.add('collapsed');
                const collapsedCommentText = comment.html_text ? stripHtmlStyling(comment.html_text) : linkifyHTML(comment.text);
                commentDiv.innerHTML = collapsedCommentText;
                button.textContent = 'Show More';
            }
        }

        async function showEarlierComments(event, taskGid) {
            event.preventDefault();
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            // Increase by 5 comments
            task.commentsShown = (task.commentsShown || 3) + 5;
            
            // Re-render task details
            await renderTaskDetails(taskGid);
        }
        
        let commentEditor = null;
        
        function showCommentBox(taskGid) {
            const editorContainer = document.getElementById(`comment-editor-${taskGid}`);
            
            // Clear any existing content in the editor container
            editorContainer.innerHTML = '';
            
            document.getElementById(`new-comment-${taskGid}`).style.display = 'block';
            document.getElementById(`add-comment-btn-${taskGid}`).style.display = 'none';
            
            // Clean up existing editor if present
            if (commentEditor) {
                commentEditor.container = null;
                commentEditor = null;
            }
            
            // Initialize fresh Quill editor
            commentEditor = new Quill(`#comment-editor-${taskGid}`, {
                theme: 'snow',
                modules: {
                    toolbar: [
                        ['bold', 'italic', 'underline', 'strike'],
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                        ['link'],
                        ['clean']
                    ]
                },
                placeholder: 'Write a comment...'
            });
            
            commentEditor.focus();
        }
        
        async function cancelComment(taskGid) {
            if (commentEditor) {
                commentEditor.container = null;
                commentEditor = null;
            }
            
            // Re-render to reset the UI completely
            await renderTaskDetails(taskGid);
        }
        
        async function saveComment(taskGid) {
            if (!commentEditor) return;
            
            const commentText = commentEditor.getText().trim();
            
            if (!commentText) {
                showToast('Please enter a comment', 'error');
                return;
            }
            
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}/stories`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { text: commentText } })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to add comment');
                }
                
                // Clean up editor
                commentEditor.container = null;
                commentEditor = null;
                
                // Reload comments
                const task = allTasksMap.get(taskGid);
                task.comments = null; // Clear to force reload
                await loadComments(taskGid);
                
                // Re-render
                await renderTaskDetails(taskGid);
                
                showToast('Comment added successfully!', 'success', 2000);
                
            } catch (error) {
                showToast('Failed to add comment: ' + error.message, 'error');
            }
        }
        
        let editingCommentEditor = null;
        
        async function editComment(event, taskGid, commentGid) {
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            const comment = task.comments.find(c => c.gid === commentGid);
            if (!comment) return;
            
            // Hide content, show editor
            document.getElementById(`comment-content-${commentGid}`).style.display = 'none';
            const editorDiv = document.getElementById(`comment-edit-${commentGid}`);
            editorDiv.style.display = 'block';
            editorDiv.innerHTML = `
                <div class="editor-container" style="margin-top: 10px;">
                    <div id="edit-comment-editor-${commentGid}"></div>
                </div>
                <div style="margin-top: 8px;">
                    <button class="btn-edit" style="opacity: 1; pointer-events: auto;" onclick="saveCommentEdit('${taskGid}', '${commentGid}')">Save</button>
                    <button class="btn-secondary" onclick="cancelCommentEdit('${commentGid}')" style="margin-left: 8px;">Cancel</button>
                </div>
            `;
            
            // Initialize editor with existing content
            if (editingCommentEditor) {
                editingCommentEditor.container = null;
            }
            
            editingCommentEditor = new Quill(`#edit-comment-editor-${commentGid}`, {
                theme: 'snow',
                modules: {
                    toolbar: [
                        ['bold', 'italic', 'underline', 'strike'],
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                        ['link'],
                        ['clean']
                    ]
                }
            });
            
            // Load existing comment text
            const commentText = comment.text || '';
            editingCommentEditor.setText(commentText);
            editingCommentEditor.focus();
        }
        
        function cancelCommentEdit(commentGid) {
            document.getElementById(`comment-content-${commentGid}`).style.display = 'block';
            document.getElementById(`comment-edit-${commentGid}`).style.display = 'none';
            if (editingCommentEditor) {
                editingCommentEditor.container = null;
                editingCommentEditor = null;
            }
        }
        
        async function saveCommentEdit(taskGid, commentGid) {
            if (!editingCommentEditor) return;
            
            const commentText = editingCommentEditor.getText().trim();
            
            if (!commentText) {
                showToast('Comment cannot be empty', 'error');
                return;
            }
            
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/stories/${commentGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { text: commentText } })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to update comment');
                }
                
                // Clean up editor
                editingCommentEditor.container = null;
                editingCommentEditor = null;
                
                // Reload comments
                const task = allTasksMap.get(taskGid);
                task.comments = null;
                await loadComments(taskGid);
                
                // Re-render
                await renderTaskDetails(taskGid);
                
                showToast('Comment updated successfully!', 'success', 2000);
                
            } catch (error) {
                showToast('Failed to update comment: ' + error.message, 'error');
            }
        }
        
        async function deleteComment(event, taskGid, commentGid) {
            event.stopPropagation();
            
            if (!confirm('Are you sure you want to delete this comment?')) {
                return;
            }
            
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/stories/${commentGid}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`
                    }
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to delete comment');
                }
                
                // Reload comments
                const task = allTasksMap.get(taskGid);
                task.comments = null;
                await loadComments(taskGid);
                
                // Re-render
                await renderTaskDetails(taskGid);
                
                showToast('Comment deleted successfully!', 'success', 2000);
                
            } catch (error) {
                showToast('Failed to delete comment: ' + error.message, 'error');
            }
        }

        async function loadComments(taskGid) {
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}/stories?opt_fields=type,text,html_text,created_at,created_by,created_by.name`, {
                    headers: { 'Authorization': `Bearer ${personalAccessToken}` }
                });

                if (!response.ok) return;

                const data = await response.json();
                const task = allTasksMap.get(taskGid);
                
                task.comments = data.data.filter(story => 
                    story.type === 'comment' && (story.text || story.html_text)
                );
            } catch (error) {
                console.error('Error loading comments:', error);
            }
        }

        function getIncompleteSubtasks(task) {
            const incomplete = [];
            if (!task || !task.subtasks || task.subtasks.length === 0) {
                return incomplete;
            }
            
            for (const subtask of task.subtasks) {
                if (!subtask.completed) {
                    incomplete.push(subtask);
                }
                // Recursively check subtask's subtasks
                const childIncomplete = getIncompleteSubtasks(subtask);
                incomplete.push(...childIncomplete);
            }
            
            return incomplete;
        }

        function showSubtaskCompletionModal(taskGid, incompleteCount) {
            const task = allTasksMap.get(taskGid);
            const content = `
                <p>This task has <strong>${incompleteCount} incomplete subtask${incompleteCount > 1 ? 's' : ''}</strong>.</p>
                <p>Would you like to mark ${incompleteCount > 1 ? 'them' : 'it'} as complete as well?</p>
            `;
            const buttons = [
                {
                    text: 'Complete Task Only',
                    onclick: `completeTaskOnly('${taskGid}')`
                },
                {
                    text: 'Complete All',
                    onclick: `completeTaskAndSubtasks('${taskGid}')`
                }
            ];
            showGenericModal('Complete Task with Subtasks?', content, buttons);
        }

        async function completeTaskOnly(taskGid) {
            closeGenericModal();
            await markTaskComplete(taskGid, false);
        }

        async function completeTaskAndSubtasks(taskGid) {
            closeGenericModal();
            await markTaskComplete(taskGid, true);
        }

        async function markTaskComplete(taskGid, includeSubtasks) {
            const task = allTasksMap.get(taskGid);
            
            try {
                // Mark main task complete
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { completed: true } })
                });

                if (!response.ok) throw new Error('Failed to update task');

                task.completed = true;

                // Update UI for main task
                const taskElement = document.querySelector(`[data-task-id="${taskGid}"]`);
                if (taskElement) {
                    updateTaskCompletionUI(taskElement, task, true);
                }

                // Mark all subtasks complete if requested
                let completedSubtaskCount = 0;
                if (includeSubtasks) {
                    const incompleteSubtasks = getIncompleteSubtasks(task);
                    completedSubtaskCount = incompleteSubtasks.length;
                    for (const subtask of incompleteSubtasks) {
                        await markSubtaskComplete(subtask.gid);
                    }
                }

                showToast(`Task${completedSubtaskCount > 0 ? ' and subtasks' : ''} marked as complete`, 'success', 2000);

                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });

            } catch (error) {
                // Revert checkbox on error
                const taskElement = document.querySelector(`[data-task-id="${taskGid}"]`);
                const checkbox = taskElement?.querySelector('.task-checkbox');
                if (checkbox) checkbox.checked = false;
                showToast('Failed to update task: ' + error.message, 'error');
            }
        }

        async function markSubtaskComplete(subtaskGid) {
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${subtaskGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { completed: true } })
                });

                if (!response.ok) throw new Error('Failed to update subtask');

                const subtask = allTasksMap.get(subtaskGid);
                if (subtask) {
                    subtask.completed = true;
                    
                    // Update UI if subtask is visible
                    const subtaskElement = document.querySelector(`[data-task-id="${subtaskGid}"]`);
                    if (subtaskElement) {
                        updateTaskCompletionUI(subtaskElement, subtask, true);
                    }
                }
            } catch (error) {
                console.error(`Failed to complete subtask ${subtaskGid}:`, error);
            }
        }

        function updateTaskCompletionUI(taskElement, task, completed) {
            const taskName = taskElement.querySelector('.task-name');
            const dueDateButton = taskElement.querySelector('.due-date');
            const checkbox = taskElement.querySelector('.task-checkbox');
            
            if (completed) {
                taskElement.classList.add('completed');
                if (taskName) taskName.classList.add('completed');
                if (checkbox) checkbox.checked = true;
                
                // Remove overdue styling
                if (dueDateButton) {
                    dueDateButton.classList.remove('overdue');
                }
                
                // Auto-collapse completed task
                const detailsDiv = document.getElementById('details-' + task.gid);
                const expandIcon = taskElement.querySelector('.expand-icon');
                if (detailsDiv && detailsDiv.style.display !== 'none') {
                    detailsDiv.style.display = 'none';
                    if (expandIcon) expandIcon.textContent = '‚ñ∂';
                    expandStates[task.gid] = false;
                    saveExpandStates();
                }
            } else {
                taskElement.classList.remove('completed');
                if (taskName) taskName.classList.remove('completed');
                if (checkbox) checkbox.checked = false;
                
                // Re-check if task is overdue
                if (dueDateButton && task.due_on) {
                    const dueDate = new Date(task.due_on);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    if (dueDate < today) {
                        dueDateButton.classList.add('overdue');
                    }
                }
            }
            
            // Update parent non-tasks styling
            let currentParent = task.parent;
            while (currentParent) {
                const parentTask = allTasksMap.get(currentParent.gid);
                
                if (parentTask && (parentTask.isSection || parentTask.isProject || parentTask.isPlaceholder)) {
                    const parentElement = document.querySelector(`[data-task-id="${currentParent.gid}"]`);
                    
                    if (parentElement) {
                        const allDescendantsComplete = areAllDescendantsComplete(parentTask);
                        const parentTaskName = parentElement.querySelector('.task-name');
                        
                        if (allDescendantsComplete) {
                            parentElement.classList.add('completed');
                            if (parentTaskName) parentTaskName.classList.add('completed');
                        } else {
                            parentElement.classList.remove('completed');
                            if (parentTaskName) parentTaskName.classList.remove('completed');
                        }
                    }
                }
                currentParent = parentTask ? parentTask.parent : null;
            }
        }

        async function toggleTaskCompletion(event, taskGid) {
            event.stopPropagation();
            const checkbox = event.target;
            const completed = checkbox.checked;

            // If marking complete and task has incomplete subtasks, prompt user
            if (completed) {
                const task = allTasksMap.get(taskGid);
                const incompleteSubtasks = getIncompleteSubtasks(task);
                
                if (incompleteSubtasks.length > 0) {
                    // Uncheck checkbox temporarily until user decides
                    checkbox.checked = false;
                    
                    // Show modal asking if user wants to complete subtasks too
                    showSubtaskCompletionModal(taskGid, incompleteSubtasks.length);
                    return;
                }
            }

            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { completed } })
                });

                if (!response.ok) throw new Error('Failed to update task');

                const task = allTasksMap.get(taskGid);
                task.completed = completed;

                const taskElement = checkbox.closest('.task-item');
                updateTaskCompletionUI(taskElement, task, completed);

                showToast(`Task marked as ${completed ? 'complete' : 'incomplete'}`, 'success', 2000);

                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });

            } catch (error) {
                checkbox.checked = !completed;
                showToast('Failed to update task: ' + error.message, 'error');
            }
        }

        async function editTaskNotes(event, taskGid) {
            event.stopPropagation();
            const task = allTasksMap.get(taskGid);
            const detailsDiv = document.getElementById('details-' + taskGid);
            
            if (detailsDiv.style.display === 'none') {
                detailsDiv.style.display = 'block';
            }

            if (activeEditor) {
                activeEditor.container = null;
            }

            const editorId = 'editor-' + taskGid;
            detailsDiv.innerHTML = `
                <div class="editor-container">
                    <div id="${editorId}"></div>
                </div>
                <div class="editor-actions">
                    <button class="btn-edit" onclick="saveTaskNotes('${taskGid}')" style="opacity: 1; pointer-events: auto;">Save</button>
                    <button class="btn-secondary" onclick="cancelEdit('${taskGid}')">Cancel</button>
                </div>
            `;

            activeEditor = new Quill('#' + editorId, {
                theme: 'snow',
                modules: {
                    toolbar: [
                        [{ 'header': [1, 2, 3, false] }],
                        ['bold', 'italic', 'underline', 'strike'],
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                        [{ 'color': [] }, { 'background': [] }],
                        ['link', 'code-block'],
                        ['clean']
                    ]
                }
            });

            // Use html_notes if available (includes proper formatting)
            if (task.html_notes) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(task.html_notes, 'text/html');
                let content = doc.body.innerHTML;
                
                // Convert line breaks to paragraphs for Quill
                // Each line becomes a paragraph to match how it displays with pre-line
                const lines = content.split(/\n/);
                const paragraphs = lines.map(line => {
                    const trimmed = line.trim();
                    // Empty lines become empty paragraphs (for spacing)
                    return '<p>' + (trimmed || '<br>') + '</p>';
                }).join('');
                
                activeEditor.clipboard.dangerouslyPasteHTML(paragraphs);
            } else if (task.notes) {
                activeEditor.clipboard.dangerouslyPasteHTML(task.notes);
            }
        }

        async function saveTaskNotes(taskGid) {
            if (!activeEditor) return;

            // Get the HTML from Quill
            const htmlNotes = activeEditor.root.innerHTML;
            
            // Also get plain text version as fallback
            const plainNotes = activeEditor.getText();

            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { notes: plainNotes } })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to save notes');
                }

                const task = allTasksMap.get(taskGid);
                task.notes = plainNotes;
                task.html_notes = htmlNotes;

                activeEditor = null;
                renderTaskDetails(taskGid);
                
                showToast('Task notes saved successfully!', 'success', 2000);

                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });

            } catch (error) {
                showToast('Failed to save notes: ' + error.message, 'error');
            }
        }

        function cancelEdit(taskGid) {
            activeEditor = null;
            const task = allTasksMap.get(taskGid);
            if (task.comments === null) {
                document.getElementById('details-' + taskGid).style.display = 'none';
            } else {
                renderTaskDetails(taskGid);
            }
        }

        async function renameTask(event, taskGid) {
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            const newName = prompt('Enter new task name:', task.name);
            if (!newName || newName.trim() === '' || newName === task.name) return;
            
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ data: { name: newName.trim() } })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to rename task');
                }
                
                // Update local cache
                task.name = newName.trim();
                
                // Re-render the task
                const taskElement = document.querySelector(`[data-task-id="${taskGid}"]`);
                if (taskElement) {
                    const level = parseInt(taskElement.style.marginLeft || '0') / 5;
                    const isRoot = !task.parent;
                    const newElement = renderTask(task, level, isRoot);
                    taskElement.replaceWith(newElement);
                }
                
                showToast('Task renamed successfully!', 'success', 2000);
                
                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });
                
            } catch (error) {
                showToast('Failed to rename task: ' + error.message, 'error');
            }
        }

        async function createSubtask(event, parentGid) {
            event.stopPropagation();
            
            const taskName = prompt('Enter new subtask name:');
            if (!taskName || taskName.trim() === '') return;
            
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${parentGid}/subtasks`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        data: { 
                            name: taskName.trim(),
                            workspace: WORKSPACE_ID
                        } 
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to create subtask');
                }
                
                const result = await response.json();
                const newSubtask = result.data;
                
                // Add to parent's subtasks
                const parent = allTasksMap.get(parentGid);
                if (!parent.subtasks) parent.subtasks = [];
                
                // Add full subtask info to map
                newSubtask.parent = { gid: parentGid };
                allTasksMap.set(newSubtask.gid, newSubtask);
                parent.subtasks.push(newSubtask);
                
                // Expand parent if not already expanded
                if (!expandStates[parentGid]) {
                    expandStates[parentGid] = true;
                    saveExpandStates();
                }
                
                // Re-render parent task
                const taskElement = document.querySelector(`[data-task-id="${parentGid}"]`);
                if (taskElement) {
                    const level = parseInt(taskElement.style.marginLeft || '0') / 5;
                    const isRoot = !parent.parent;
                    const newElement = renderTask(parent, level, isRoot);
                    taskElement.replaceWith(newElement);
                }
                
                showToast('Subtask created successfully!', 'success', 2000);
                
                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });
                
            } catch (error) {
                showToast('Failed to create subtask: ' + error.message, 'error');
            }
        }

        async function markAllDescendantsComplete(event, taskGid) {
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            // Get all incomplete descendants
            const incompleteDescendants = [];
            function collectIncomplete(t) {
                const isNonTask = t.isSection || t.isProject || t.isPlaceholder;
                // Only mark actual tasks as complete, not non-tasks
                if (!isNonTask && !t.completed) {
                    incompleteDescendants.push(t);
                }
                if (t.subtasks) {
                    t.subtasks.forEach(st => {
                        const subtask = allTasksMap.get(st.gid);
                        if (subtask) collectIncomplete(subtask);
                    });
                }
            }
            collectIncomplete(task);
            
            if (incompleteDescendants.length === 0) {
                showToast('All descendants are already complete', 'info', 2000);
                return;
            }
            
            // Show confirmation modal
            const taskCount = incompleteDescendants.length;
            const taskWord = taskCount > 1 ? 'tasks' : 'task';
            const content = `
                <p>This will mark <strong>${taskCount} incomplete ${taskWord}</strong> as complete.</p>
                <p>Are you sure you want to continue?</p>
            `;
            
            showGenericModal('Mark All Complete', content, [
                {
                    text: 'Cancel',
                    class: 'btn-secondary',
                    onclick: 'closeGenericModal()'
                },
                {
                    text: 'Mark Complete',
                    class: 'btn-edit',
                    onclick: `closeGenericModal(); executeMarkAllComplete('${taskGid}');`
                }
            ]);
        }
        
        async function executeMarkAllComplete(taskGid) {
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            // Re-collect incomplete descendants (in case state changed)
            const incompleteDescendants = [];
            function collectIncomplete(t) {
                const isNonTask = t.isSection || t.isProject || t.isPlaceholder;
                if (!isNonTask && !t.completed) {
                    incompleteDescendants.push(t);
                }
                if (t.subtasks) {
                    t.subtasks.forEach(st => {
                        const subtask = allTasksMap.get(st.gid);
                        if (subtask) collectIncomplete(subtask);
                    });
                }
            }
            collectIncomplete(task);
            
            try {
                showProgress();
                updateProgress(0, incompleteDescendants.length, 'Marking tasks complete...');
                
                // Mark all as complete
                for (let i = 0; i < incompleteDescendants.length; i++) {
                    const descendant = incompleteDescendants[i];
                    
                    const response = await fetch(`https://app.asana.com/api/1.0/tasks/${descendant.gid}`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${personalAccessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ data: { completed: true } })
                    });
                    
                    if (!response.ok) throw new Error('Failed to update task');
                    
                    // Update local state
                    descendant.completed = true;
                    
                    // Update UI for this task
                    const taskElement = document.querySelector(`[data-task-id="${descendant.gid}"]`);
                    if (taskElement) {
                        updateTaskCompletionUI(taskElement, descendant, true);
                    }
                    
                    updateProgress(i + 1, incompleteDescendants.length, `Marked ${i + 1} of ${incompleteDescendants.length} complete...`);
                }
                
                hideProgress();
                showToast(`Marked ${incompleteDescendants.length} task${incompleteDescendants.length > 1 ? 's' : ''} as complete!`, 'success', 3000);
                
                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });
                
            } catch (error) {
                hideProgress();
                showToast('Failed to mark tasks complete: ' + error.message, 'error');
            }
        }

        async function setDueDate(event, taskGid) {
            event.stopPropagation();
            
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            // Create a temporary input element for date picking
            const input = document.createElement('input');
            input.type = 'date';
            input.value = task.due_on || '';
            input.style.position = 'fixed';
            input.style.top = event.clientY + 'px';
            input.style.left = event.clientX + 'px';
            input.style.zIndex = '10000';
            
            document.body.appendChild(input);
            
            // Handle date selection
            const handleDateChange = async () => {
                const dateInput = input.value;
                
                // Remove event listeners first
                input.removeEventListener('change', handleDateChange);
                input.removeEventListener('blur', handleCancel);
                
                // Remove input if still in DOM
                if (document.body.contains(input)) {
                    document.body.removeChild(input);
                }
                
                // If no date selected and had a date before, ask if they want to remove it
                if (!dateInput && task.due_on) {
                    if (!confirm('Remove the due date?')) return;
                }
                
                // If no change, just return
                if (dateInput === task.due_on || (!dateInput && !task.due_on)) return;
                
                await saveDueDate(taskGid, dateInput);
            };
            
            // Handle cancel
            const handleCancel = () => {
                // Remove event listeners first
                input.removeEventListener('change', handleDateChange);
                input.removeEventListener('blur', handleCancel);
                
                // Remove input if still in DOM
                if (document.body.contains(input)) {
                    document.body.removeChild(input);
                }
            };
            
            input.addEventListener('change', handleDateChange);
            input.addEventListener('blur', handleCancel);
            
            // Open the date picker
            input.focus();
            input.showPicker();
        }
        
        async function saveDueDate(taskGid, dateInput) {
            const task = allTasksMap.get(taskGid);
            if (!task) return;
            
            // Clean up the date input
            const cleanDate = dateInput ? dateInput.trim() : '';
            
            try {
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${personalAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        data: { 
                            due_on: cleanDate || null 
                        } 
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.errors?.[0]?.message || 'Failed to set due date');
                }
                
                // Update local cache
                if (cleanDate) {
                    task.due_on = cleanDate;
                } else {
                    delete task.due_on;
                }
                
                // Re-render the task
                const taskElement = document.querySelector(`[data-task-id="${taskGid}"]`);
                if (taskElement) {
                    const level = parseInt(taskElement.style.marginLeft || '0') / 5;
                    const isRoot = !task.parent;
                    const newElement = renderTask(task, level, isRoot);
                    taskElement.replaceWith(newElement);
                }
                
                const message = dateInput.trim() ? 'Due date set successfully!' : 'Due date removed!';
                showToast(message, 'success', 2000);
                
                // Update cache
                saveCache({
                    allTasksMap: Array.from(allTasksMap.entries()),
                    rootItems: rootItems,
                    allParents: Array.from(allParents)
                });
                
            } catch (error) {
                showToast('Failed to set due date: ' + error.message, 'error');
            }
        }

        // Generic modal system - reusable for any modal content
        function showGenericModal(title, content, buttons = []) {
            const modal = document.getElementById('genericModal');
            const modalContent = document.getElementById('genericModalContent');
            
            let buttonsHtml = '';
            if (buttons.length > 0) {
                buttonsHtml = '<div class="modal-footer">';
                buttons.forEach((btn, index) => {
                    const btnClass = btn.class || (index === buttons.length - 1 ? 'btn-edit' : 'btn-secondary');
                    const btnStyle = btnClass === 'btn-edit' ? 'opacity: 1; pointer-events: auto;' : '';
                    buttonsHtml += `<button class="${btnClass}" onclick="${btn.onclick}" style="${btnStyle}">${btn.text}</button>`;
                });
                buttonsHtml += '</div>';
            } else {
                // Default close button
                buttonsHtml = '<div class="modal-footer"><button onclick="closeGenericModal()">Close</button></div>';
            }
            
            modalContent.innerHTML = `
                <h2>${title}</h2>
                <div class="modal-body">
                    ${content}
                </div>
                ${buttonsHtml}
            `;
            
            modal.classList.add('active');
        }

        function closeGenericModal() {
            document.getElementById('genericModal').classList.remove('active');
        }

        function showInfoModal() {
            const info = window.taskDebugInfo || {};
            
            const content = `
                <div style="font-size: 1.1em; line-height: 1.8;">
                    <p><strong>üìä Task Statistics:</strong></p>
                    <ul style="list-style: none; padding-left: 20px;">
                        <li>‚Ä¢ Showing: <strong>${info.afterFilters || 0} root items</strong></li>
                        <li>‚Ä¢ Total tasks: <strong>${info.totalTasks || 0}</strong></li>
                        <li>‚Ä¢ Completed: <strong>${info.completedTasks || 0}</strong></li>
                        <li>‚Ä¢ Remaining: <strong>${info.remainingTasks || 0}</strong></li>
                    </ul>
                    
                    <p style="margin-top: 20px;"><strong> Data Source:</strong></p>
                    <ul style="list-style: none; padding-left: 20px;">
                        <li>‚Ä¢ <strong>${info.dataSource || 'Unknown'}</strong></li>
                    </ul>
                </div>
            `;
            
            showGenericModal('Task Information', content);
        }

        // Filter modal functions
        function showFilterModal() {
            const modal = document.getElementById('filterModal');
            modal.classList.add('active');

            // Set current values
            document.querySelector(`input[name="completionFilter"][value="${filterState.completion}"]`).checked = true;
            document.getElementById('dateRangeType').value = filterState.dateRange;
            
            if (filterState.dateRange === 'custom') {
                document.getElementById('customDateRange').style.display = 'block';
                if (filterState.customStart) {
                    document.getElementById('startDate').value = filterState.customStart;
                }
                if (filterState.customEnd) {
                    document.getElementById('endDate').value = filterState.customEnd;
                }
            }
        }

        function closeFilterModal() {
            document.getElementById('filterModal').classList.remove('active');
        }

        function toggleCustomDateRange() {
            const rangeType = document.getElementById('dateRangeType').value;
            const customRange = document.getElementById('customDateRange');
            customRange.style.display = rangeType === 'custom' ? 'block' : 'none';
        }

        async function applyFilters() {
            // Get values
            const oldCompletion = filterState.completion;
            const oldDateRange = filterState.dateRange;
            
            filterState.completion = document.querySelector('input[name="completionFilter"]:checked').value;
            filterState.dateRange = document.getElementById('dateRangeType').value;
            filterState.parentFilter = document.getElementById('parentFilter').value;

            if (filterState.dateRange === 'custom') {
                filterState.customStart = document.getElementById('startDate').value;
                filterState.customEnd = document.getElementById('endDate').value;
            }

            saveFilterState();
            
            // Display filter badges immediately so user sees them right away
            displayFilterBadges();
            
            closeFilterModal();

            // Check if we need to reload from API
            const dateRangeChanged = oldDateRange !== filterState.dateRange;
            const completionChanged = oldCompletion !== filterState.completion;
            
            // Intelligent caching: Date filters are now applied CLIENT-SIDE
            // Only reload if cache doesn't encompass the requested scope
            if (dateRangeChanged) {
                const cacheResult = loadCache();
                
                if (cacheResult) {
                    // Cache encompasses requested scope - use it!
                    debugLog(`‚úÖ Using cached data (scope: ${cacheResult.broadestScope} encompasses ${filterState.dateRange})`);
                    displayCachedData();
                    showToast('Filter applied (using cached data)', 'success', 2000);
                    
                    // Still do background refresh to get any updated tasks
                    const lastFetch = cacheResult.lastFetchTimes[filterState.dateRange] || cacheResult.timestamp;
                    setTimeout(() => refreshData(true, lastFetch), 1000);
                } else {
                    // Cache doesn't encompass requested scope - need to fetch
                    debugLog(`‚ùå Cache miss or narrower scope - fetching data for ${filterState.dateRange}`);
                    showProgress();
                    updateProgress(0, 100, 'Loading tasks...');
                    await loadUserTasks(false);
                }
            } else {
                // Only completion or parent filter changed - re-display existing data (instant!)
                if (completionChanged) {
                    debugLog('‚ú® Completion filter changed - applying client-side filter (instant)');
                }
                displayTasks();
                showToast('Filter applied', 'success', 1000);
            }
        }

        function displayFilterBadges() {
            const badgesDiv = document.getElementById('filterBadges');
            badgesDiv.innerHTML = '';

            const chips = [];

            // Only show completion chip if not showing all tasks
            if (filterState.completion !== 'both') {
                const completionLabels = {
                    'incomplete': 'Incomplete Tasks',
                    'completed': 'Completed Tasks'
                };
                chips.push({
                    label: completionLabels[filterState.completion],
                    onDelete: () => {
                        const previousFilter = filterState.completion;
                        filterState.completion = 'both';
                        saveFilterState();
                        displayTasks();
                        displayFilterBadges();
                        
                        // Provide feedback about the filter change
                        const tasks = Array.from(allTasksMap.values());
                        const completedCount = tasks.filter(t => t.completed && !t.isProject && !t.isSection && !t.isPlaceholder).length;
                        const incompleteCount = tasks.filter(t => !t.completed && !t.isProject && !t.isSection && !t.isPlaceholder).length;
                        
                        if (previousFilter === 'incomplete' && completedCount === 0) {
                            showToast('Now showing all tasks (no completed tasks found)', 'info', 3000);
                        } else if (previousFilter === 'completed' && incompleteCount === 0) {
                            showToast('Now showing all tasks (no incomplete tasks found)', 'info', 3000);
                        } else {
                            showToast(`Now showing all tasks (${incompleteCount} incomplete, ${completedCount} completed)`, 'success', 3000);
                        }
                    }
                });
            }

            // Only show date chip if not showing all dates
            if (filterState.dateRange !== 'all') {
                const labels = {
                    'last7': 'Last 7 days',
                    'last30': 'Last 30 days',
                    'last90': 'Last 90 days',
                    'custom': 'Custom range'
                };
                chips.push({
                    label: labels[filterState.dateRange],
                    onDelete: async () => {
                        const oldDateRange = filterState.dateRange;
                        debugLog(`üóëÔ∏è Date filter chip deleted. Old: ${oldDateRange}, New: all`);
                        debugLog(`   Before: filterState.dateRange = ${filterState.dateRange}`);
                        
                        filterState.dateRange = 'all';
                        filterState.customStart = null;
                        filterState.customEnd = null;
                        saveFilterState();
                        
                        debugLog(`   After: filterState.dateRange = ${filterState.dateRange}`);
                        debugLog(`   rootItems.length = ${rootItems.length}`);
                        debugLog(`   allTasksMap.size = ${allTasksMap.size}`);
                        
                        // Check if cache already has all tasks
                        const cached = loadCache();
                        debugLog(`   Cache check: broadestScope = ${cached?.broadestScope}`);
                        
                        if (cached && cached.broadestScope === 'all') {
                            // Cache encompasses 'all' scope - just filter client-side
                            debugLog(`‚ú® Switching from ${oldDateRange} to 'all' - using cached data (no API call)`);
                            debugLog(`   Calling displayTasks()...`);
                            showToast('Date filter removed (using cached data)', 'success', 2000);
                            displayTasks();
                            debugLog(`   displayTasks() completed`);
                            displayFilterBadges();
                            debugLog(`   displayFilterBadges() completed`);
                        } else {
                            // Need to fetch all tasks
                            debugLog(`   Cache doesn't have 'all' scope - need to reload`);
                            showToast('Reloading to fetch all tasks...', 'info', 2000);
                            await loadUserTasks();
                            displayFilterBadges();
                        }
                    }
                });
            }

            // Only show parent chip if a parent filter is active
            if (filterState.parentFilter) {
                const parent = allTasksMap.get(filterState.parentFilter);
                if (parent) {
                    chips.push({
                        label: 'Project: ' + parent.name,
                        onDelete: () => {
                            const parentName = parent.name;
                            filterState.parentFilter = '';
                            document.getElementById('parentFilter').value = '';
                            saveFilterState();
                            displayTasks();
                            displayFilterBadges();
                            showToast(`Showing all projects (removed filter: ${parentName})`, 'success', 3000);
                        }
                    });
                }
            }

            // Add sort chips for active sorts
            const activeSorts = Object.entries(sortState.columns)
                .filter(([_, state]) => state.order !== 'none')
                .sort((a, b) => a[1].priority - b[1].priority);
            
            const sortLabels = {
                'modified': 'Modified',
                'due_date': 'Due Date',
                'completed': 'Status',
                'name': 'Name'
            };
            
            const orderSymbols = {
                'asc': '‚Üë',
                'desc': '‚Üì'
            };
            
            activeSorts.forEach(([field, state]) => {
                const indicator = orderSymbols[state.order];
                const dimension = sortLabels[field];
                const prioritySubscript = activeSorts.length > 1 ? toSubscript(state.priority) : '';
                chips.push({
                    label: `${indicator} ${dimension}${prioritySubscript}`,
                    onDelete: () => {
                        removeSortDimension(field);
                    }
                });
            });

            // Create chip elements
            chips.forEach(chip => {
                const chipDiv = document.createElement('div');
                chipDiv.className = 'filter-chip';
                
                const label = document.createElement('span');
                label.textContent = chip.label;
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'filter-chip-delete';
                deleteBtn.innerHTML = '√ó';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    // Remove chip immediately for instant feedback
                    chipDiv.remove();
                    // Then execute the delete handler
                    chip.onDelete();
                };
                deleteBtn.title = 'Remove filter';
                
                chipDiv.appendChild(label);
                chipDiv.appendChild(deleteBtn);
                badgesDiv.appendChild(chipDiv);
            });
        }

        // Utility functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function linkifyHTML(html) {
            const urlRegex = /(https?:\/\/[^\s<]+)/g;
            return html.replace(urlRegex, '<a href="$1" target="_blank" style="color: #2c7873; text-decoration: underline;">$1</a>');
        }

        function stripHtmlStyling(html) {
            if (!html) return '';
            
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Remove all style attributes and certain formatting tags
            const elementsWithStyle = doc.querySelectorAll('[style]');
            elementsWithStyle.forEach(el => el.removeAttribute('style'));
            
            // Remove span, font, and other pure styling tags but keep their content
            const stylingTags = doc.querySelectorAll('span, font, div');
            stylingTags.forEach(el => {
                // Replace the element with its content
                const parent = el.parentNode;
                while (el.firstChild) {
                    parent.insertBefore(el.firstChild, el);
                }
                parent.removeChild(el);
            });
            
            // Keep semantic tags: a, ul, ol, li, p, strong, em, b, i, br
            // Everything else gets stripped but content preserved
            
            return doc.body.innerHTML;
        }

        function logout() {
            if (confirm('Are you sure you want to logout? This will clear your cached data.')) {
                clearPAT();
                clearWorkspaceId();
                clearCache();
                location.reload();
            }
        }

        // Initialize on page load
        // Close modals when clicking outside
        window.onclick = function(event) {
            const genericModal = document.getElementById('genericModal');
            const filterModal = document.getElementById('filterModal');
            
            if (event.target === genericModal) {
                closeGenericModal();
            }
            if (event.target === filterModal) {
                closeFilterModal();
            }
        };

        // Toolbar scroll behavior
        let lastScrollTop = 0;
        let scrollTimeout = null;
        let isCompact = false;
        let isTransitioning = false; // Prevent changes during CSS transitions
        const SCROLL_THRESHOLD = 20; // Minimum scroll distance to trigger state change
        const HEADER_HEIGHT = 200; // Approximate height of header banner
        
        function handleToolbarScroll() {
            const controls = document.querySelector('.controls');
            if (!controls || isTransitioning) return;
            
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            
            // Calculate scroll difference
            const scrollDiff = scrollTop - lastScrollTop;
            const scrollDiffAbs = Math.abs(scrollDiff);
            
            // Ignore very small scroll changes
            if (scrollDiffAbs < 1) return;
            
            // Compact activates at 150px, but only deactivates when back above header (200px)
            const shouldBeCompact = scrollTop > 150 && (isCompact || scrollTop <= HEADER_HEIGHT ? scrollTop > HEADER_HEIGHT : true);
            
            // Handle compact state
            if (shouldBeCompact !== isCompact && scrollDiffAbs >= SCROLL_THRESHOLD) {
                isCompact = shouldBeCompact;
                isTransitioning = true;
                if (isCompact) {
                    controls.classList.add('compact');
                } else {
                    controls.classList.remove('compact');
                }
                // Allow transitions to complete
                setTimeout(() => { isTransitioning = false; }, 350);
                lastScrollTop = scrollTop;
            } else if (scrollDiffAbs > SCROLL_THRESHOLD) {
                lastScrollTop = scrollTop;
            }
        }
        
        // Throttle scroll events more aggressively
        window.addEventListener('scroll', function() {
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            scrollTimeout = setTimeout(handleToolbarScroll, 150);
        }, { passive: true });

        window.onload = function() {
            loadExpandStates();
            initializeSortButtons();
            const savedToken = loadPAT();
            const savedWorkspaceId = loadWorkspaceId();
            if (savedToken) {
                personalAccessToken = savedToken;
                WORKSPACE_ID = savedWorkspaceId; // May be null, will be fetched during auth if needed
                authenticateAndLoad();
            }
            
            // Show Clear Cache button if ?debug URL parameter is present
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('debug')) {
                const clearCacheBtn = document.getElementById('clearCacheBtn');
                if (clearCacheBtn) {
                    clearCacheBtn.style.display = '';
                }
                // Apply debug mode background color
                document.body.classList.add('debug-mode');
                // Show debug mode indicator in header
                const debugIndicator = document.getElementById('debugIndicator');
                if (debugIndicator) {
                    debugIndicator.style.display = 'block';
                }
            }
            
            // Add ALT key listener to show/hide enter-debug-mode link
            const enterDebugLink = document.getElementById('enterDebugMode');
            if (enterDebugLink && !urlParams.has('debug')) {
                document.addEventListener('keydown', function(e) {
                    if (e.altKey && !urlParams.has('debug')) {
                        enterDebugLink.style.display = 'block';
                    }
                });
                
                document.addEventListener('keyup', function(e) {
                    if (!e.altKey) {
                        enterDebugLink.style.display = 'none';
                    }
                });
            }
        };
        
        // Function to enter debug mode
        function enterDebugMode() {
            const currentUrl = window.location.href.split('?')[0];
            window.location.href = currentUrl + '?debug';
        }
        
        // Function to exit debug mode
        function exitDebugMode() {
            const currentUrl = window.location.href.split('?')[0];
            window.location.href = currentUrl;
        }
    </script>
</body>
</html>
